<!DOCTYPE html>
<!-- saved from url=(0046)https://golang.org/pkg/math/big/?m=all#Int.Rem -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>big - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="./big - The Go Programming Language_files/style.css">

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="https://golang.org/opensearch.xml">

<link rel="stylesheet" href="./big - The Go Programming Language_files/jquery.treeview.css">
<script type="text/javascript" async="" src="./big - The Go Programming Language_files/ga.js"></script><script type="text/javascript">window.initFuncs = [];</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
  _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
  _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
};
</script>
<style id="style-1-cropbar-clipper">/* Copyright 2014 Evernote Corporation. All rights reserved. */
.en-markup-crop-options {
    top: 18px !important;
    left: 50% !important;
    margin-left: -100px !important;
    width: 200px !important;
    border: 2px rgba(255,255,255,.38) solid !important;
    border-radius: 4px !important;
}

.en-markup-crop-options div div:first-of-type {
    margin-left: 0px !important;
}
</style></head>
<body>

<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="https://golang.org/">The Go Programming Language</a></div>
<div class="top-heading" id="heading-narrow"><a href="https://golang.org/">Go</a></div>
<a href="https://golang.org/pkg/math/big/?m=all#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form method="GET" action="https://golang.org/search">
<div id="menu" style="min-width: 60px;">
<a href="https://golang.org/doc/">Documents</a>
<a href="https://golang.org/pkg/">Packages</a>
<a href="https://golang.org/project/">The Project</a>
<a href="https://golang.org/help/">Help</a>
<a href="https://golang.org/blog/">Blog</a>

<a id="playgroundButton" href="http://play.golang.org/" title="Show Go Playground">Play</a>

<input type="text" id="search" name="q" class="inactive" value="Search" placeholder="Search">
</div>
</form>

</div></div>


<div id="playground" class="play">
	<div class="input"><textarea class="code" spellcheck="false">package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}</textarea></div>
	<div class="output"></div>
	<div class="buttons">
		<a class="run" title="Run this code [shift-enter]">Run</a>
		<a class="fmt" title="Format this code">Format</a>
		
		<a class="share" title="Share this code">Share</a>
		
	</div>
</div>


<div id="page" class="wide" tabindex="-1" style="outline: 0px;">
<div class="container">


  <h1>Package big</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script type="text/javascript">
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "math/big"</code></dd>
			</dl>
			<dl>
			<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package big implements arbitrary-precision arithmetic (big numbers).
The following numeric types are supported:
</p>
<pre>Int    signed integers
Rat    rational numbers
Float  floating-point numbers
</pre>
<p>
The zero value for an Int, Rat, or Float correspond to 0. Thus, new
values can be declared in the usual ways and denote 0 without further
initialization:
</p>
<pre>var x Int        // &amp;x is an *Int of value 0
var r = &amp;Rat{}   // r is a *Rat of value 0
y := new(Float)  // y is a *Float of value 0
</pre>
<p>
Alternatively, new values can be allocated and initialized with factory
functions of the form:
</p>
<pre>func NewT(v V) *T
</pre>
<p>
For instance, NewInt(x) returns an *Int set to the value of the int64
argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where
a and b are int64 values, and NewFloat(f) returns a *Float initialized
to the float64 argument f. More flexibility is provided with explicit
setters, for instance:
</p>
<pre>var z1 Int
z1.SetUint64(123)                 // z1 := 123
z2 := new(Rat).SetFloat64(1.2)    // z2 := 6/5
z3 := new(Float).SetInt(z1)       // z3 := 123.0
</pre>
<p>
Setters, numeric operations and predicates are represented as methods of
the form:
</p>
<pre>func (z *T) SetV(v V) *T          // z = v
func (z *T) Unary(x *T) *T        // z = unary x
func (z *T) Binary(x, y *T) *T    // z = x binary y
func (x *T) Pred() P              // p = pred(x)
</pre>
<p>
with T one of Int, Rat, or Float. For unary and binary operations, the
result is the receiver (usually named z in that case; see below); if it
is one of the operands x or y it may be safely overwritten (and its memory
reused).
</p>
<p>
Arithmetic expressions are typically written as a sequence of individual
method calls, with each call corresponding to an operation. The receiver
denotes the result and the method arguments are the operation's operands.
For instance, given three *Int values a, b and c, the invocation
</p>
<pre>c.Add(a, b)
</pre>
<p>
computes the sum a + b and stores the result in c, overwriting whatever
value was held in c before. Unless specified otherwise, operations permit
aliasing of parameters, so it is perfectly ok to write
</p>
<pre>sum.Add(sum, x)
</pre>
<p>
to accumulate values x in a sum.
</p>
<p>
(By always passing in a result value via the receiver, memory use can be
much better controlled. Instead of having to allocate new memory for each
result, an operation can reuse the space allocated for the result value,
and overwrite that value with the new result in the process.)
</p>
<p>
Notational convention: Incoming method parameters (including the receiver)
are named consistently in the API to clarify their use. Incoming operands
are usually named x, y, a, b, and so on, but never z. A parameter specifying
the result is named z (typically the receiver).
</p>
<p>
For instance, the arguments for (*Int).Add are named x and y, and because
the receiver specifies the result destination, it is called z:
</p>
<pre>func (z *Int) Add(x, y *Int) *Int
</pre>
<p>
Methods of this form typically return the incoming receiver as well, to
enable simple call chaining.
</p>
<p>
Methods which don't require a result value to be passed in (for instance,
Int.Sign), simply return the result. In this case, the receiver is typically
the first operand, named x:
</p>
<pre>func (x *Int) Sign() int
</pre>
<p>
Various methods support conversions between strings and corresponding
numeric values, and vice versa: *Int, *Rat, and *Float values implement
the Stringer interface for a (default) string representation of the value,
but also provide SetString methods to initialize a value from a string in
a variety of supported formats (see the respective SetString documentation).
</p>
<p>
Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface
for scanning and (except for *Rat) the Formatter interface for formatted
printing.
</p>

			</div>
		</div>
		<div id="example__eConvergents" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (EConvergents)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (EConvergents)</span></p>
		<p>This example demonstrates how to use big.Rat to compute the
first 15 terms in the sequence of rational convergents for
the constant e (base of natural logarithm).
</p>
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

// Use the classic continued fraction for e
//     e = [1; 0, 1, 1, 2, 1, 1, ... 2n, 1, 1, ...]
// i.e., for the nth term, use
//     1          if   n mod 3 != 1
//  (n-1)/3 * 2   if   n mod 3 == 1
func recur(n, lim int64) *big.Rat {
	term := new(big.Rat)
	if n%3 != 1 {
		term.SetInt64(1)
	} else {
		term.SetInt64((n - 1) / 3 * 2)
	}

	if n &gt; lim {
		return term
	}

	// Directly initialize frac as the fractional
	// inverse of the result of recur.
	frac := new(big.Rat).Inv(recur(n+1, lim))

	return term.Add(term, frac)
}

// This example demonstrates how to use big.Rat to compute the
// first 15 terms in the sequence of rational convergents for
// the constant e (base of natural logarithm).
func main() {
	for i := 1; i &lt;= 15; i++ {
		r := recur(0, int64(i))

		// Print r both as a fraction and as a floating-point number.
		// Since big.Rat implements fmt.Formatter, we can use %-13s to
		// get a left-aligned string representation of the fraction.
		fmt.Printf("%-13s = %s\n", r, r.FloatString(8))
	}

}
</textarea></div>
				<div class="output"><pre>2/1           = 2.00000000
3/1           = 3.00000000
8/3           = 2.66666667
11/4          = 2.75000000
19/7          = 2.71428571
87/32         = 2.71875000
106/39        = 2.71794872
193/71        = 2.71830986
1264/465      = 2.71827957
1457/536      = 2.71828358
2721/1001     = 2.71828172
23225/8544    = 2.71828184
25946/9545    = 2.71828182
49171/18089   = 2.71828183
517656/190435 = 2.71828183
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>
<div id="example__fibonacci" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Fibonacci)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Fibonacci)</span></p>
		<p>This example demonstrates how to use big.Int to compute the smallest
Fibonacci number with 100 decimal digits and to test whether it is prime.
</p>
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

func main() {
	// Initialize two big ints with the first two numbers in the sequence.
	a := big.NewInt(0)
	b := big.NewInt(1)

	// Initialize limit as 10^99, the smallest integer with 100 digits.
	var limit big.Int
	limit.Exp(big.NewInt(10), big.NewInt(99), nil)

	// Loop while a is smaller than 1e100.
	for a.Cmp(&amp;limit) &lt; 0 {
		// Compute the next Fibonacci number, storing it in a.
		a.Add(a, b)
		// Swap a and b so that b is the next number in the sequence.
		a, b = b, a
	}
	fmt.Println(a) // 100-digit Fibonacci number

	// Test a for primality.
	// (ProbablyPrimes' argument sets the number of Miller-Rabin
	// rounds to be performed. 20 is a good value.)
	fmt.Println(a.ProbablyPrime(20))

}
</textarea></div>
				<div class="output"><pre>1344719667586153181419716641724567886890850696275767987106294472017884974410332069524504824747437757
false
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>
<div id="example__sqrt2" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Sqrt2)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Sqrt2)</span></p>
		<p>This example shows how to use big.Float to compute the square root of 2 with
a precision of 200 bits, and how to print the result as a decimal number.
</p>
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math"
	"math/big"
)

func main() {
	// We'll do computations with 200 bits of precision in the mantissa.
	const prec = 200

	// Compute the square root of 2 using Newton's Method. We start with
	// an initial estimate for sqrt(2), and then iterate:
	//     x_{n+1} = 1/2 * ( x_n + (2.0 / x_n) )

	// Since Newton's Method doubles the number of correct digits at each
	// iteration, we need at least log_2(prec) steps.
	steps := int(math.Log2(prec))

	// Initialize values we need for the computation.
	two := new(big.Float).SetPrec(prec).SetInt64(2)
	half := new(big.Float).SetPrec(prec).SetFloat64(0.5)

	// Use 1 as the initial estimate.
	x := new(big.Float).SetPrec(prec).SetInt64(1)

	// We use t as a temporary variable. There's no need to set its precision
	// since big.Float values with unset (== 0) precision automatically assume
	// the largest precision of the arguments when used as the result (receiver)
	// of a big.Float operation.
	t := new(big.Float)

	// Iterate.
	for i := 0; i &lt;= steps; i++ {
		t.Quo(two, x)  // t = 2.0 / x_n
		t.Add(x, t)    // t = x_n + (2.0 / x_n)
		x.Mul(half, t) // x_{n+1} = 0.5 * t
	}

	// We can use the usual fmt.Printf verbs since big.Float implements fmt.Formatter
	fmt.Printf("sqrt(2) = %.50f\n", x)

	// Print the error between 2 and x*x.
	t.Mul(x, x) // t = x*x
	fmt.Printf("error = %e\n", t.Sub(two, t))

}
</textarea></div>
				<div class="output"><pre>sqrt(2) = 1.41421356237309504880168872420969807856967187537695
error = 0.000000e+00
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>


		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Jacobi">func Jacobi(x, y *Int) int</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#addAt">func addAt(z, x nat, i int)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#addWW_g">func addWW_g(x, y, c Word) (z1, z0 Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#alias">func alias(x, y nat) bool</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#appendZeros">func appendZeros(buf []byte, n int) []byte</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#basicMul">func basicMul(z, x, y nat)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#bitLen">func bitLen(x Word) (n int)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#bitLen_g">func bitLen_g(x Word) (n int)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#divWW">func divWW(x1, x0, y Word) (q, r Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#divWW_g">func divWW_g(u1, u0, v Word) (q, r Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#divisors">func divisors(m int, b Word, ndigits int, bb Word) []divisor</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#fmtE">func fmtE(buf []byte, fmt byte, prec int, d decimal) []byte</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#fmtF">func fmtF(buf []byte, prec int, d decimal) []byte</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#fnorm">func fnorm(m nat) int64</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#greaterThan">func greaterThan(x1, x2, y1, y2 Word) bool</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#karatsuba">func karatsuba(z, x, y nat)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#karatsubaAdd">func karatsubaAdd(z, x nat, n int)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#karatsubaLen">func karatsubaLen(n int) int</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#karatsubaSub">func karatsubaSub(z, x nat, n int)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#log2">func log2(x Word) int</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#low32">func low32(z nat) uint32</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#low64">func low64(z nat) uint64</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#max">func max(x, y int) int</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#min">func min(x, y int) int</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#msb32">func msb32(x nat) uint32</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#msb64">func msb64(x nat) uint64</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#mulAddWWW_g">func mulAddWWW_g(x, y, c Word) (z1, z0 Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#mulWW">func mulWW(x, y Word) (z1, z0 Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#mulWW_g">func mulWW_g(x, y Word) (z1, z0 Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#nlz">func nlz(x Word) uint</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#nlz64">func nlz64(x uint64) uint</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#putNat">func putNat(x nat)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#quotToFloat32">func quotToFloat32(a, b nat) (f float32, exact bool)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#quotToFloat64">func quotToFloat64(a, b nat) (f float64, exact bool)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#ratTok">func ratTok(ch rune) bool</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#roundShortest">func roundShortest(d *decimal, x *Float)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#scanExponent">func scanExponent(r io.ByteScanner, binExpOk bool) (exp int64, base int, err error)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#scanSign">func scanSign(r io.ByteScanner) (neg bool, err error)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#shouldRoundUp">func shouldRoundUp(x *decimal, n int) bool</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#shr">func shr(x *decimal, s uint)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#subWW_g">func subWW_g(x, y, c Word) (z1, z0 Word)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#trailingZeroBits">func trailingZeroBits(x Word) uint</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#trim">func trim(x *decimal)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#umax32">func umax32(x, y uint32) uint32</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#validateBinaryOperands">func validateBinaryOperands(x, y *Float)</a></dd>
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#writeMultiple">func writeMultiple(s fmt.State, text string, count int)</a></dd>
			
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Accuracy">type Accuracy</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#makeAcc">func makeAcc(above bool) Accuracy</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Accuracy.String">func (i Accuracy) String() string</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#ErrNaN">type ErrNaN</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#ErrNaN.Error">func (err ErrNaN) Error() string</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Float">type Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#NewFloat">func NewFloat(x float64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#ParseFloat">func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Abs">func (z *Float) Abs(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Acc">func (x *Float) Acc() Accuracy</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Add">func (z *Float) Add(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Append">func (x *Float) Append(buf []byte, fmt byte, prec int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Cmp">func (x *Float) Cmp(y *Float) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Copy">func (z *Float) Copy(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Float32">func (x *Float) Float32() (float32, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Float64">func (x *Float) Float64() (float64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Format">func (x *Float) Format(s fmt.State, format rune)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.GobDecode">func (z *Float) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.GobEncode">func (x *Float) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Int">func (x *Float) Int(z *Int) (*Int, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Int64">func (x *Float) Int64() (int64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.IsInf">func (x *Float) IsInf() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.IsInt">func (x *Float) IsInt() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.MantExp">func (x *Float) MantExp(mant *Float) (exp int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.MarshalText">func (x *Float) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.MinPrec">func (x *Float) MinPrec() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Mode">func (x *Float) Mode() RoundingMode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Mul">func (z *Float) Mul(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Neg">func (z *Float) Neg(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Parse">func (z *Float) Parse(s string, base int) (f *Float, b int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Prec">func (x *Float) Prec() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Quo">func (z *Float) Quo(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Rat">func (x *Float) Rat(z *Rat) (*Rat, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Set">func (z *Float) Set(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetFloat64">func (z *Float) SetFloat64(x float64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetInf">func (z *Float) SetInf(signbit bool) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetInt">func (z *Float) SetInt(x *Int) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetInt64">func (z *Float) SetInt64(x int64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetMantExp">func (z *Float) SetMantExp(mant *Float, exp int) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetMode">func (z *Float) SetMode(mode RoundingMode) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetPrec">func (z *Float) SetPrec(prec uint) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetRat">func (z *Float) SetRat(x *Rat) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetString">func (z *Float) SetString(s string) (*Float, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.SetUint64">func (z *Float) SetUint64(x uint64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Sign">func (x *Float) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Signbit">func (x *Float) Signbit() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.String">func (x *Float) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Sub">func (z *Float) Sub(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Text">func (x *Float) Text(format byte, prec int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.Uint64">func (x *Float) Uint64() (uint64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.UnmarshalText">func (z *Float) UnmarshalText(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.fmtB">func (x *Float) fmtB(buf []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.fmtP">func (x *Float) fmtP(buf []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.ord">func (x *Float) ord() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.pow5">func (z *Float) pow5(n uint64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.round">func (z *Float) round(sbit uint)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.scan">func (z *Float) scan(r io.ByteScanner, base int) (f *Float, b int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.setBits64">func (z *Float) setBits64(neg bool, x uint64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.setExpAndRound">func (z *Float) setExpAndRound(exp int64, sbit uint)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.uadd">func (z *Float) uadd(x, y *Float)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.ucmp">func (x *Float) ucmp(y *Float) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.umul">func (z *Float) umul(x, y *Float)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.uquo">func (z *Float) uquo(x, y *Float)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.usub">func (z *Float) usub(x, y *Float)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Float.validate">func (x *Float) validate()</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Int">type Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#NewInt">func NewInt(x int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#scaleDenom">func scaleDenom(x *Int, f nat) *Int</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Abs">func (z *Int) Abs(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Add">func (z *Int) Add(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.And">func (z *Int) And(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.AndNot">func (z *Int) AndNot(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Append">func (x *Int) Append(buf []byte, base int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Binomial">func (z *Int) Binomial(n, k int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Bit">func (x *Int) Bit(i int) uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.BitLen">func (x *Int) BitLen() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Bits">func (x *Int) Bits() []Word</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Bytes">func (x *Int) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Cmp">func (x *Int) Cmp(y *Int) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Div">func (z *Int) Div(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.DivMod">func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Exp">func (z *Int) Exp(x, y, m *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Format">func (x *Int) Format(s fmt.State, ch rune)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.GCD">func (z *Int) GCD(x, y, a, b *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.GobDecode">func (z *Int) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.GobEncode">func (x *Int) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Int64">func (x *Int) Int64() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Lsh">func (z *Int) Lsh(x *Int, n uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.MarshalJSON">func (x *Int) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.MarshalText">func (x *Int) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Mod">func (z *Int) Mod(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.ModInverse">func (z *Int) ModInverse(g, n *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.ModSqrt">func (z *Int) ModSqrt(x, p *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Mul">func (z *Int) Mul(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.MulRange">func (z *Int) MulRange(a, b int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Neg">func (z *Int) Neg(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Not">func (z *Int) Not(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Or">func (z *Int) Or(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.ProbablyPrime">func (x *Int) ProbablyPrime(n int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Quo">func (z *Int) Quo(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.QuoRem">func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Rand">func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Rem">func (z *Int) Rem(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Rsh">func (z *Int) Rsh(x *Int, n uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Scan">func (z *Int) Scan(s fmt.ScanState, ch rune) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Set">func (z *Int) Set(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetBit">func (z *Int) SetBit(x *Int, i int, b uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetBits">func (z *Int) SetBits(abs []Word) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetBytes">func (z *Int) SetBytes(buf []byte) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetInt64">func (z *Int) SetInt64(x int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetString">func (z *Int) SetString(s string, base int) (*Int, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.SetUint64">func (z *Int) SetUint64(x uint64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Sign">func (x *Int) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.String">func (x *Int) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Sub">func (z *Int) Sub(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Text">func (x *Int) Text(base int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Uint64">func (x *Int) Uint64() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.UnmarshalJSON">func (z *Int) UnmarshalJSON(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.UnmarshalText">func (z *Int) UnmarshalText(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.Xor">func (z *Int) Xor(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.binaryGCD">func (z *Int) binaryGCD(a, b *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.modSqrt3Mod4Prime">func (z *Int) modSqrt3Mod4Prime(x, p *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.modSqrtTonelliShanks">func (z *Int) modSqrtTonelliShanks(x, p *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Int.scan">func (z *Int) scan(r io.ByteScanner, base int) (*Int, int, error)</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Rat">type Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#NewRat">func NewRat(a, b int64) *Rat</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Abs">func (z *Rat) Abs(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Add">func (z *Rat) Add(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Cmp">func (x *Rat) Cmp(y *Rat) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Denom">func (x *Rat) Denom() *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Float32">func (x *Rat) Float32() (f float32, exact bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Float64">func (x *Rat) Float64() (f float64, exact bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.FloatString">func (x *Rat) FloatString(prec int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.GobDecode">func (z *Rat) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.GobEncode">func (x *Rat) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Inv">func (z *Rat) Inv(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.IsInt">func (x *Rat) IsInt() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.MarshalText">func (x *Rat) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Mul">func (z *Rat) Mul(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Neg">func (z *Rat) Neg(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Num">func (x *Rat) Num() *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Quo">func (z *Rat) Quo(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.RatString">func (x *Rat) RatString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Scan">func (z *Rat) Scan(s fmt.ScanState, ch rune) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Set">func (z *Rat) Set(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetFloat64">func (z *Rat) SetFloat64(f float64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetFrac">func (z *Rat) SetFrac(a, b *Int) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetFrac64">func (z *Rat) SetFrac64(a, b int64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetInt">func (z *Rat) SetInt(x *Int) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetInt64">func (z *Rat) SetInt64(x int64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.SetString">func (z *Rat) SetString(s string) (*Rat, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Sign">func (x *Rat) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.String">func (x *Rat) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.Sub">func (z *Rat) Sub(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.UnmarshalText">func (z *Rat) UnmarshalText(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#Rat.norm">func (z *Rat) norm() *Rat</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">type RoundingMode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode.String">func (i RoundingMode) String() string</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#Word">type Word</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addMulVVW">func addMulVVW(z, x []Word, y Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addMulVVW_g">func addMulVVW_g(z, x []Word, y Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addVV">func addVV(z, x, y []Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addVV_g">func addVV_g(z, x, y []Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addVW">func addVW(z, x []Word, y Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#addVW_g">func addVW_g(z, x []Word, y Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#divWVW">func divWVW(z []Word, xn Word, x []Word, y Word) (r Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#divWVW_g">func divWVW_g(z []Word, xn Word, x []Word, y Word) (r Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#maxPow">func maxPow(b Word) (p Word, n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#mulAddVWW">func mulAddVWW(z, x []Word, y, r Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#mulAddVWW_g">func mulAddVWW_g(z, x []Word, y, r Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#pow">func pow(x Word, n int) (p Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#shlVU">func shlVU(z, x []Word, s uint) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#shlVU_g">func shlVU_g(z, x []Word, s uint) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#shrVU">func shrVU(z, x []Word, s uint) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#shrVU_g">func shrVU_g(z, x []Word, s uint) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#subVV">func subVV(z, x, y []Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#subVV_g">func subVV_g(z, x, y []Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#subVW">func subVW(z, x []Word, y Word) (c Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#subVW_g">func subVW_g(z, x []Word, y Word) (c Word)</a></dd>
				
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#byteReader">type byteReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#byteReader.ReadByte">func (r byteReader) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#byteReader.UnreadByte">func (r byteReader) UnreadByte() error</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#decimal">type decimal</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.String">func (x *decimal) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.at">func (d *decimal) at(i int) byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.init">func (x *decimal) init(m nat, shift int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.round">func (x *decimal) round(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.roundDown">func (x *decimal) roundDown(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#decimal.roundUp">func (x *decimal) roundUp(n int)</a></dd>
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#divisor">type divisor</a></dd>
				
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#form">type form</a></dd>
				
				
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#nat">type nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#getNat">func getNat(n int) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#mulDenom">func mulDenom(z, x, y nat) nat</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.add">func (z nat) add(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.and">func (z nat) and(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.andNot">func (z nat) andNot(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.bit">func (x nat) bit(i uint) uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.bitLen">func (x nat) bitLen() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.bytes">func (z nat) bytes(buf []byte) (i int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.clear">func (z nat) clear()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.cmp">func (x nat) cmp(y nat) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.convertWords">func (q nat) convertWords(s []byte, b Word, ndigits int, bb Word, table []divisor)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.div">func (z nat) div(z2, u, v nat) (q, r nat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.divLarge">func (z nat) divLarge(u, uIn, v nat) (q, r nat)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.divW">func (z nat) divW(x nat, y Word) (q nat, r Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.expNN">func (z nat) expNN(x, y, m nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.expNNMontgomery">func (z nat) expNNMontgomery(x, y, m nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.expNNWindowed">func (z nat) expNNWindowed(x, y, m nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.expWW">func (z nat) expWW(x, y Word) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.itoa">func (x nat) itoa(neg bool, base int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.make">func (z nat) make(n int) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.modW">func (x nat) modW(d Word) (r Word)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.montgomery">func (z nat) montgomery(x, y, m nat, k Word, n int) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.mul">func (z nat) mul(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.mulAddWW">func (z nat) mulAddWW(x nat, y, r Word) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.mulRange">func (z nat) mulRange(a, b uint64) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.norm">func (z nat) norm() nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.or">func (z nat) or(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.probablyPrime">func (n nat) probablyPrime(reps int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.random">func (z nat) random(rand *rand.Rand, limit nat, n int) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.scan">func (z nat) scan(r io.ByteScanner, base int, fracOk bool) (res nat, b, count int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.set">func (z nat) set(x nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.setBit">func (z nat) setBit(x nat, i uint, b uint) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.setBytes">func (z nat) setBytes(buf []byte) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.setUint64">func (z nat) setUint64(x uint64) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.setWord">func (z nat) setWord(x Word) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.shl">func (z nat) shl(x nat, s uint) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.shr">func (z nat) shr(x nat, s uint) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.sticky">func (x nat) sticky(i uint) uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.sub">func (z nat) sub(x, y nat) nat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.trailingZeroBits">func (x nat) trailingZeroBits() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.utoa">func (x nat) utoa(base int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="https://golang.org/pkg/math/big/?m=all#nat.xor">func (z nat) xor(x, y nat) nat</a></dd>
				
			
			
				
				<dd><a href="https://golang.org/pkg/math/big/?m=all#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h4>Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Float_Add">Float.Add</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Float_Cmp">Float.Cmp</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Int_Scan">Int.Scan</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Int_SetString">Int.SetString</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Rat_Scan">Rat.Scan</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_Rat_SetString">Rat.SetString</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example_RoundingMode">RoundingMode</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example__eConvergents">Package (EConvergents)</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example__fibonacci">Package (Fibonacci)</a></dd>
			
			<dd><a class="exampleLink" href="https://golang.org/pkg/math/big/?m=all#example__sqrt2">Package (Sqrt2)</a></dd>
			
			</dl>
		</div>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="https://golang.org/src/math/big/accuracy_string.go">accuracy_string.go</a>
			
				<a href="https://golang.org/src/math/big/arith.go">arith.go</a>
			
				<a href="https://golang.org/src/math/big/arith_decl.go">arith_decl.go</a>
			
				<a href="https://golang.org/src/math/big/decimal.go">decimal.go</a>
			
				<a href="https://golang.org/src/math/big/doc.go">doc.go</a>
			
				<a href="https://golang.org/src/math/big/float.go">float.go</a>
			
				<a href="https://golang.org/src/math/big/floatconv.go">floatconv.go</a>
			
				<a href="https://golang.org/src/math/big/floatmarsh.go">floatmarsh.go</a>
			
				<a href="https://golang.org/src/math/big/ftoa.go">ftoa.go</a>
			
				<a href="https://golang.org/src/math/big/int.go">int.go</a>
			
				<a href="https://golang.org/src/math/big/intconv.go">intconv.go</a>
			
				<a href="https://golang.org/src/math/big/intmarsh.go">intmarsh.go</a>
			
				<a href="https://golang.org/src/math/big/nat.go">nat.go</a>
			
				<a href="https://golang.org/src/math/big/natconv.go">natconv.go</a>
			
				<a href="https://golang.org/src/math/big/rat.go">rat.go</a>
			
				<a href="https://golang.org/src/math/big/ratconv.go">ratconv.go</a>
			
				<a href="https://golang.org/src/math/big/ratmarsh.go">ratmarsh.go</a>
			
				<a href="https://golang.org/src/math/big/roundingmode_string.go">roundingmode_string.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		<div id="pkg-callgraph" class="toggle" style="display: none">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Internal Call Graph section">Internal call graph ▹</h2>
		</div> <!-- .expanded -->
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Internal Call Graph section">Internal call graph ▾</h2>
			<p>
			  In the call graph viewer below, each node
			  is a function belonging to this package
			  and its children are the functions it
			  calls—perhaps dynamically.
			</p>
			<p>
			  The root nodes are the entry points of the
			  package: functions that may be called from
			  outside the package.
			  There may be non-exported or anonymous
			  functions among them if they are called
			  dynamically from another package.
			</p>
			<p>
			  Click a node to visit that function's source code.
			  From there you can visit its callers by
			  clicking its declaring <code>func</code>
			  token.
			</p>
			<p>
			  Functions may be omitted if they were
			  determined to be unreachable in the
			  particular programs or tests that were
			  analyzed.
			</p>
			<!-- Zero means show all package entry points. -->
			<ul style="margin-left: 0.5in" id="callgraph-0" class="treeview"></ul>
		</div>
		</div> <!-- #pkg-callgraph -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
        <span class="comment">// Compute the size _S of a Word in bytes.</span>
        <span id="_m">_m</span>    = ^<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>(0)
        <span id="_logS">_logS</span> = _m&gt;&gt;8&amp;1 + _m&gt;&gt;16&amp;1 + _m&gt;&gt;32&amp;1
        <span id="_S">_S</span>    = 1 &lt;&lt; _logS

        <span id="_W">_W</span> = _S &lt;&lt; 3 <span class="comment">// word size in bits</span>
        <span id="_B">_B</span> = 1 &lt;&lt; _W <span class="comment">// digit base</span>
        <span id="_M">_M</span> = _B - 1  <span class="comment">// digit mask</span>

        <span id="_W2">_W2</span> = _W / 2   <span class="comment">// half word size in bits</span>
        <span id="_B2">_B2</span> = 1 &lt;&lt; _W2 <span class="comment">// half digit base</span>
        <span id="_M2">_M2</span> = _B2 - 1  <span class="comment">// half digit mask</span>
)</pre>
				
			
				<pre>const (
        <span id="MaxExp">MaxExp</span>  = <a href="https://golang.org/pkg/math/">math</a>.<a href="https://golang.org/pkg/math/#MaxInt32">MaxInt32</a>  <span class="comment">// largest supported exponent</span>
        <span id="MinExp">MinExp</span>  = <a href="https://golang.org/pkg/math/">math</a>.<a href="https://golang.org/pkg/math/#MinInt32">MinInt32</a>  <span class="comment">// smallest supported exponent</span>
        <span id="MaxPrec">MaxPrec</span> = <a href="https://golang.org/pkg/math/">math</a>.<a href="https://golang.org/pkg/math/#MaxUint32">MaxUint32</a> <span class="comment">// largest (theoretically) supported precision; likely memory-limited</span>
)</pre>
				<p>
Exponent and precision limits.
</p>

			
				<pre>const <span id="MaxBase">MaxBase</span> = 'z' - 'a' + 10 + 1</pre>
				<p>
MaxBase is the largest number base accepted for string conversions.
</p>

			
				<pre>const <span id="_Accuracy_name">_Accuracy_name</span> = "BelowExactAbove"</pre>
				
			
				<pre>const <span id="_RoundingMode_name">_RoundingMode_name</span> = "ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf"</pre>
				
			
				<pre>const <span id="deBruijn32">deBruijn32</span> = 0x077CB531</pre>
				
			
				<pre>const <span id="deBruijn64">deBruijn64</span> = 0x03f79d71b4ca8b09</pre>
				
			
				<pre>const <span id="debugFloat">debugFloat</span> = <a href="https://golang.org/pkg/builtin/#false">false</a> <span class="comment">// enable for debugging</span>
</pre>
				
			
				<pre>const <span id="digits">digits</span> = "0123456789abcdefghijklmnopqrstuvwxyz"</pre>
				
			
				<pre>const <span id="floatGobVersion">floatGobVersion</span> <a href="https://golang.org/pkg/builtin/#byte">byte</a> = 1</pre>
				<p>
Gob codec version. Permits backward-compatible changes to the encoding.
</p>

			
				<pre>const <span id="intGobVersion">intGobVersion</span> <a href="https://golang.org/pkg/builtin/#byte">byte</a> = 1</pre>
				<p>
Gob codec version. Permits backward-compatible changes to the encoding.
</p>

			
				<pre>const <span id="maxShift">maxShift</span> = _W - 4</pre>
				<p>
Maximum shift amount that can be done in one pass without overflow.
A Word has _W bits and (1&lt;&lt;maxShift - 1)*10 + 9 must fit into Word.
</p>

			
				<pre>const <span id="ratGobVersion">ratGobVersion</span> <a href="https://golang.org/pkg/builtin/#byte">byte</a> = 1</pre>
				<p>
Gob codec version. Permits backward-compatible changes to the encoding.
</p>

			
				<pre>const <span id="use_addWW_g">use_addWW_g</span> = <a href="https://golang.org/pkg/builtin/#false">false</a></pre>
				<p>
Keep for performance debugging.
Using addWW_g is likely slower.
</p>

			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
        <span id="natOne">natOne</span> = nat{1}
        <span id="natTwo">natTwo</span> = nat{2}
        <span id="natTen">natTen</span> = nat{10}
)</pre>
				
			
				<pre>var <span id="_Accuracy_index">_Accuracy_index</span> = [...]<a href="https://golang.org/pkg/builtin/#uint8">uint8</a>{0, 5, 10, 15}</pre>
				
			
				<pre>var <span id="_RoundingMode_index">_RoundingMode_index</span> = [...]<a href="https://golang.org/pkg/builtin/#uint8">uint8</a>{0, 13, 26, 32, 44, 57, 70}</pre>
				
			
				<pre>var <span id="cacheBase10">cacheBase10</span> struct {
        <a href="https://golang.org/pkg/sync/">sync</a>.<a href="https://golang.org/pkg/sync/#Mutex">Mutex</a>
        table [64]divisor <span class="comment">// cached divisors for base 10</span>
}</pre>
				
			
				<pre>var <span id="deBruijn32Lookup">deBruijn32Lookup</span> = []<a href="https://golang.org/pkg/builtin/#byte">byte</a>{
        0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
        31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9,
}</pre>
				
			
				<pre>var <span id="deBruijn64Lookup">deBruijn64Lookup</span> = []<a href="https://golang.org/pkg/builtin/#byte">byte</a>{
        0, 1, 56, 2, 57, 49, 28, 3, 61, 58, 42, 50, 38, 29, 17, 4,
        62, 47, 59, 36, 45, 43, 51, 22, 53, 39, 33, 30, 24, 18, 12, 5,
        63, 55, 48, 27, 60, 41, 37, 16, 46, 35, 44, 21, 52, 32, 23, 11,
        54, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 9, 13, 8, 7, 6,
}</pre>
				
			
				<pre>var <span id="intOne">intOne</span> = &amp;<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>{<a href="https://golang.org/pkg/builtin/#false">false</a>, natOne}</pre>
				
			
				<pre>var <span id="karatsubaThreshold">karatsubaThreshold</span> <a href="https://golang.org/pkg/builtin/#int">int</a> = 40 <span class="comment">// computed by calibrate.go</span>
</pre>
				<p>
Operands that are shorter than karatsubaThreshold are multiplied using
"grade school" multiplication; for longer operands the Karatsuba algorithm
is used.
</p>

			
				<pre>var <span id="leafSize">leafSize</span> <a href="https://golang.org/pkg/builtin/#int">int</a> = 8 <span class="comment">// number of Word-size binary values treat as a monolithic block</span>
</pre>
				<p>
Split blocks greater than leafSize Words (or set to 0 to disable recursive conversion)
Benchmark and configure leafSize using: go test -bench="Leaf"
</p>
<pre>8 and 16 effective on 3.0 GHz Xeon "Clovertown" CPU (128 byte cache lines)
8 and 16 effective on 2.66 GHz Core 2 Duo "Penryn" CPU
</pre>

			
				<pre>var <span id="natPool">natPool</span> <a href="https://golang.org/pkg/sync/">sync</a>.<a href="https://golang.org/pkg/sync/#Pool">Pool</a></pre>
				
			
				<pre>var <span id="pow5tab">pow5tab</span> = [...]<a href="https://golang.org/pkg/builtin/#uint64">uint64</a>{
        1,
        5,
        25,
        125,
        625,
        3125,
        15625,
        78125,
        390625,
        1953125,
        9765625,
        48828125,
        244140625,
        1220703125,
        6103515625,
        30517578125,
        152587890625,
        762939453125,
        3814697265625,
        19073486328125,
        95367431640625,
        476837158203125,
        2384185791015625,
        11920928955078125,
        59604644775390625,
        298023223876953125,
        1490116119384765625,
        7450580596923828125,
}</pre>
				<p>
These powers of 5 fit into a uint64.
</p>
<pre>for p, q := uint64(0), uint64(1); p &lt; q; p, q = q, q*5 {
	fmt.Println(q)
}
</pre>

			
		
		
			
			
			<h2 id="Jacobi">func <a href="https://golang.org/src/math/big/int.go?s=13915:13941#L583">Jacobi</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Jacobi">¶</a>
			</h2>
			<pre>func Jacobi(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
			<p>
Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.
The y argument must be an odd integer.
</p>

			
			

		
			
			
			<h2 id="addAt">func <a href="https://golang.org/src/math/big/nat.go?s=8393:8420#L360">addAt</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addAt">¶</a>
			</h2>
			<pre>func addAt(z, x nat, i <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			<p>
addAt implements z += x&lt;&lt;(_W*i); z must be long enough.
(we don't use nat.add because we need z to stay the same
slice, and we don't need to normalize z after each addition)
</p>

			
			

		
			
			
			<h2 id="addWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=1014:1054#L25">addWW_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addWW_g">¶</a>
			</h2>
			<pre>func addWW_g(x, y, c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (z1, z0 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
z1&lt;&lt;_W + z0 = x+y+c, with c == 0 or 1
</p>

			
			

		
			
			
			<h2 id="alias">func <a href="https://golang.org/src/math/big/nat.go?s=8094:8119#L353">alias</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#alias">¶</a>
			</h2>
			<pre>func alias(x, y nat) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
			<p>
alias reports whether x and y share the same base array.
</p>

			
			

		
			
			
			<h2 id="appendZeros">func <a href="https://golang.org/src/math/big/decimal.go?s=5000:5042#L178">appendZeros</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#appendZeros">¶</a>
			</h2>
			<pre>func appendZeros(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, n <a href="https://golang.org/pkg/builtin/#int">int</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
			<p>
appendZeros appends n 0 digits to buf and returns buf.
</p>

			
			

		
			
			
			<h2 id="basicMul">func <a href="https://golang.org/src/math/big/nat.go?s=3285:3311#L183">basicMul</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#basicMul">¶</a>
			</h2>
			<pre>func basicMul(z, x, y nat)</pre>
			<p>
basicMul multiplies x and y and leaves the result in z.
The (non-normalized) result is placed in z[0 : len(x) + len(y)].
</p>

			
			

		
			
			
			<h2 id="bitLen">func <a href="https://golang.org/src/math/big/arith_decl.go?s=698:725#L11">bitLen</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#bitLen">¶</a>
			</h2>
			<pre>func bitLen(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			
			
			

		
			
			
			<h2 id="bitLen_g">func <a href="https://golang.org/src/math/big/arith.go?s=1763:1792#L71">bitLen_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#bitLen_g">¶</a>
			</h2>
			<pre>func bitLen_g(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			<p>
Length of x in bits.
</p>

			
			

		
			
			
			<h2 id="divWW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=272:310#L1">divWW</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divWW">¶</a>
			</h2>
			<pre>func divWW(x1, x0, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (q, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			
			
			

		
			
			
			<h2 id="divWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=2607:2647#L122">divWW_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divWW_g">¶</a>
			</h2>
			<pre>func divWW_g(u1, u0, v <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (q, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
q = (u1&lt;&lt;_W + u0 - r)/y
Adapted from Warren, Hacker's Delight, p. 152.
</p>

			
			

		
			
			
			<h2 id="divisors">func <a href="https://golang.org/src/math/big/natconv.go?s=12190:12250#L430">divisors</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divisors">¶</a>
			</h2>
			<pre>func divisors(m <a href="https://golang.org/pkg/builtin/#int">int</a>, b <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, ndigits <a href="https://golang.org/pkg/builtin/#int">int</a>, bb <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) []divisor</pre>
			<p>
construct table of powers of bb*leafSize to use in subdivisions
</p>

			
			

		
			
			
			<h2 id="fmtE">func <a href="https://golang.org/src/math/big/ftoa.go?s=6851:6910#L228">fmtE</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#fmtE">¶</a>
			</h2>
			<pre>func fmtE(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, fmt <a href="https://golang.org/pkg/builtin/#byte">byte</a>, prec <a href="https://golang.org/pkg/builtin/#int">int</a>, d decimal) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
			<p>
%e: d.ddddde±dd
</p>

			
			

		
			
			
			<h2 id="fmtF">func <a href="https://golang.org/src/math/big/ftoa.go?s=7611:7660#L272">fmtF</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#fmtF">¶</a>
			</h2>
			<pre>func fmtF(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, prec <a href="https://golang.org/pkg/builtin/#int">int</a>, d decimal) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
			<p>
%f: ddddddd.ddddd
</p>

			
			

		
			
			
			<h2 id="fnorm">func <a href="https://golang.org/src/math/big/float.go?s=15966:15989#L554">fnorm</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#fnorm">¶</a>
			</h2>
			<pre>func fnorm(m nat) <a href="https://golang.org/pkg/builtin/#int64">int64</a></pre>
			<p>
fnorm normalizes mantissa m by shifting it to the left
such that the msb of the most-significant word (msw) is 1.
It returns the shift amount. It assumes that len(m) != 0.
</p>

			
			

		
			
			
			<h2 id="greaterThan">func <a href="https://golang.org/src/math/big/nat.go?s=18367:18409#L857">greaterThan</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#greaterThan">¶</a>
			</h2>
			<pre>func greaterThan(x1, x2, y1, y2 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
			<p>
greaterThan reports whether (x1&lt;&lt;_W + x2) &gt; (y1&lt;&lt;_W + y2)
</p>

			
			

		
			
			
			<h2 id="karatsuba">func <a href="https://golang.org/src/math/big/nat.go?s=5542:5569#L257">karatsuba</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#karatsuba">¶</a>
			</h2>
			<pre>func karatsuba(z, x, y nat)</pre>
			<p>
karatsuba multiplies x and y and leaves the result in z.
Both x and y must have the same length n and n must be a
power of 2. The result vector z must have len(z) &gt;= 6*n.
The (non-normalized) result is placed in z[0 : 2*n].
</p>

			
			

		
			
			
			<h2 id="karatsubaAdd">func <a href="https://golang.org/src/math/big/nat.go?s=4814:4848#L235">karatsubaAdd</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#karatsubaAdd">¶</a>
			</h2>
			<pre>func karatsubaAdd(z, x nat, n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			<p>
Fast version of z[0:n+n&gt;&gt;1].add(z[0:n+n&gt;&gt;1], x[0:n]) w/o bounds checks.
Factored out for readability - do not use outside karatsuba.
</p>

			
			

		
			
			
			<h2 id="karatsubaLen">func <a href="https://golang.org/src/math/big/nat.go?s=8907:8935#L382">karatsubaLen</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#karatsubaLen">¶</a>
			</h2>
			<pre>func karatsubaLen(n <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
			<p>
karatsubaLen computes an approximation to the maximum k &lt;= n such that
k = p&lt;&lt;i for a number p &lt;= karatsubaThreshold and an i &gt;= 0. Thus, the
result is the largest number that can be divided repeatedly by 2 before
becoming about the value of karatsubaThreshold.
</p>

			
			

		
			
			
			<h2 id="karatsubaSub">func <a href="https://golang.org/src/math/big/nat.go?s=4968:5002#L242">karatsubaSub</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#karatsubaSub">¶</a>
			</h2>
			<pre>func karatsubaSub(z, x nat, n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			<p>
Like karatsubaAdd, but does subtract.
</p>

			
			

		
			
			
			<h2 id="log2">func <a href="https://golang.org/src/math/big/arith.go?s=2131:2152#L96">log2</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#log2">¶</a>
			</h2>
			<pre>func log2(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
			<p>
log2 computes the integer binary logarithm of x.
The result is the integer n for which 2^n &lt;= x &lt; 2^(n+1).
If x == 0, the result is -1.
</p>

			
			

		
			
			
			<h2 id="low32">func <a href="https://golang.org/src/math/big/int.go?s=7792:7816#L318">low32</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#low32">¶</a>
			</h2>
			<pre>func low32(z nat) <a href="https://golang.org/pkg/builtin/#uint32">uint32</a></pre>
			<p>
low32 returns the least significant 32 bits of z.
</p>

			
			

		
			
			
			<h2 id="low64">func <a href="https://golang.org/src/math/big/int.go?s=7928:7952#L326">low64</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#low64">¶</a>
			</h2>
			<pre>func low64(z nat) <a href="https://golang.org/pkg/builtin/#uint64">uint64</a></pre>
			<p>
low64 returns the least significant 64 bits of z.
</p>

			
			

		
			
			
			<h2 id="max">func <a href="https://golang.org/src/math/big/nat.go?s=8569:8591#L371">max</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#max">¶</a>
			</h2>
			<pre>func max(x, y <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
			
			
			

		
			
			
			<h2 id="min">func <a href="https://golang.org/src/math/big/ftoa.go?s=9749:9771#L362">min</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#min">¶</a>
			</h2>
			<pre>func min(x, y <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
			
			
			

		
			
			
			<h2 id="msb32">func <a href="https://golang.org/src/math/big/float.go?s=18651:18675#L668">msb32</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#msb32">¶</a>
			</h2>
			<pre>func msb32(x nat) <a href="https://golang.org/pkg/builtin/#uint32">uint32</a></pre>
			<p>
msb32 returns the 32 most significant bits of x.
</p>

			
			

		
			
			
			<h2 id="msb64">func <a href="https://golang.org/src/math/big/float.go?s=18957:18981#L686">msb64</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#msb64">¶</a>
			</h2>
			<pre>func msb64(x nat) <a href="https://golang.org/pkg/builtin/#uint64">uint64</a></pre>
			<p>
msb64 returns the 64 most significant bits of x.
</p>

			
			

		
			
			
			<h2 id="mulAddWWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=1616:1660#L62">mulAddWWW_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulAddWWW_g">¶</a>
			</h2>
			<pre>func mulAddWWW_g(x, y, c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (z1, z0 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
z1&lt;&lt;_W + z0 = x*y + c
</p>

			
			

		
			
			
			<h2 id="mulWW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=236:271#L1">mulWW</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulWW">¶</a>
			</h2>
			<pre>func mulWW(x, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (z1, z0 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
implemented in arith_$GOARCH.s
</p>

			
			

		
			
			
			<h2 id="mulWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=1356:1393#L46">mulWW_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulWW_g">¶</a>
			</h2>
			<pre>func mulWW_g(x, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (z1, z0 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
z1&lt;&lt;_W + z0 = x*y
Adapted from Warren, Hacker's Delight, p. 132.
</p>

			
			

		
			
			
			<h2 id="nlz">func <a href="https://golang.org/src/math/big/arith.go?s=2229:2250#L101">nlz</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nlz">¶</a>
			</h2>
			<pre>func nlz(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
			<p>
nlz returns the number of leading zeros in x.
</p>

			
			

		
			
			
			<h2 id="nlz64">func <a href="https://golang.org/src/math/big/arith.go?s=2336:2361#L106">nlz64</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nlz64">¶</a>
			</h2>
			<pre>func nlz64(x <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
			<p>
nlz64 returns the number of leading zeros in x.
</p>

			
			

		
			
			
			<h2 id="putNat">func <a href="https://golang.org/src/math/big/nat.go?s=12393:12411#L544">putNat</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#putNat">¶</a>
			</h2>
			<pre>func putNat(x nat)</pre>
			
			
			

		
			
			
			<h2 id="quotToFloat32">func <a href="https://golang.org/src/math/big/rat.go?s=1644:1696#L58">quotToFloat32</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#quotToFloat32">¶</a>
			</h2>
			<pre>func quotToFloat32(a, b nat) (f <a href="https://golang.org/pkg/builtin/#float32">float32</a>, exact <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
			<p>
quotToFloat32 returns the non-negative float32 value
nearest to the quotient a/b, using round-to-even in
halfway cases. It does not mutate its arguments.
Preconditions: b is non-zero; a and b have no common factors.
</p>

			
			

		
			
			
			<h2 id="quotToFloat64">func <a href="https://golang.org/src/math/big/rat.go?s=4368:4420#L156">quotToFloat64</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#quotToFloat64">¶</a>
			</h2>
			<pre>func quotToFloat64(a, b nat) (f <a href="https://golang.org/pkg/builtin/#float64">float64</a>, exact <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
			<p>
quotToFloat64 returns the non-negative float64 value
nearest to the quotient a/b, using round-to-even in
halfway cases. It does not mutate its arguments.
Preconditions: b is non-zero; a and b have no common factors.
</p>

			
			

		
			
			
			<h2 id="ratTok">func <a href="https://golang.org/src/math/big/ratconv.go?s=291:316#L7">ratTok</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#ratTok">¶</a>
			</h2>
			<pre>func ratTok(ch <a href="https://golang.org/pkg/builtin/#rune">rune</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
			
			
			

		
			
			
			<h2 id="roundShortest">func <a href="https://golang.org/src/math/big/ftoa.go?s=4406:4446#L153">roundShortest</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#roundShortest">¶</a>
			</h2>
			<pre>func roundShortest(d *decimal, x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
			
			
			

		
			
			
			<h2 id="scanExponent">func <a href="https://golang.org/src/math/big/ratconv.go?s=3031:3114#L123">scanExponent</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#scanExponent">¶</a>
			</h2>
			<pre>func scanExponent(r <a href="https://golang.org/pkg/io/">io</a>.<a href="https://golang.org/pkg/io/#ByteScanner">ByteScanner</a>, binExpOk <a href="https://golang.org/pkg/builtin/#bool">bool</a>) (exp <a href="https://golang.org/pkg/builtin/#int64">int64</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
			<p>
scanExponent scans the longest possible prefix of r representing a decimal
('e', 'E') or binary ('p') exponent, if any. It returns the exponent, the
exponent base (10 or 2), or a read or syntax error, if any.
</p>
<pre>exponent = ( "E" | "e" | "p" ) [ sign ] digits .
sign     = "+" | "-" .
digits   = digit { digit } .
digit    = "0" ... "9" .
</pre>
<p>
A binary exponent is only permitted if binExpOk is set.
</p>

			
			

		
			
			
			<h2 id="scanSign">func <a href="https://golang.org/src/math/big/intconv.go?s=5433:5486#L182">scanSign</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#scanSign">¶</a>
			</h2>
			<pre>func scanSign(r <a href="https://golang.org/pkg/io/">io</a>.<a href="https://golang.org/pkg/io/#ByteScanner">ByteScanner</a>) (neg <a href="https://golang.org/pkg/builtin/#bool">bool</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
			
			
			

		
			
			
			<h2 id="shouldRoundUp">func <a href="https://golang.org/src/math/big/decimal.go?s=5227:5269#L188">shouldRoundUp</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shouldRoundUp">¶</a>
			</h2>
			<pre>func shouldRoundUp(x *decimal, n <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
			<p>
shouldRoundUp reports if x should be rounded up
if shortened to n digits. n must be a valid index
for x.mant.
</p>

			
			

		
			
			
			<h2 id="shr">func <a href="https://golang.org/src/math/big/decimal.go?s=3428:3456#L94">shr</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shr">¶</a>
			</h2>
			<pre>func shr(x *decimal, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>)</pre>
			<p>
shr implements x &gt;&gt; s, for s &lt;= maxShift.
</p>

			
			

		
			
			
			<h2 id="subWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=1170:1210#L35">subWW_g</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#subWW_g">¶</a>
			</h2>
			<pre>func subWW_g(x, y, c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (z1, z0 <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
			<p>
z1&lt;&lt;_W + z0 = x-y-c, with c == 0 or 1
</p>

			
			

		
			
			
			<h2 id="trailingZeroBits">func <a href="https://golang.org/src/math/big/nat.go?s=15011:15045#L659">trailingZeroBits</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#trailingZeroBits">¶</a>
			</h2>
			<pre>func trailingZeroBits(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
			<p>
trailingZeroBits returns the number of consecutive least significant zero
bits of x.
</p>

			
			

		
			
			
			<h2 id="trim">func <a href="https://golang.org/src/math/big/decimal.go?s=6506:6527#L247">trim</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#trim">¶</a>
			</h2>
			<pre>func trim(x *decimal)</pre>
			<p>
trim cuts off any trailing zeros from x's mantissa;
they are meaningless for the value of x.
</p>

			
			

		
			
			
			<h2 id="umax32">func <a href="https://golang.org/src/math/big/float.go?s=43841:43872#L1668">umax32</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#umax32">¶</a>
			</h2>
			<pre>func umax32(x, y <a href="https://golang.org/pkg/builtin/#uint32">uint32</a>) <a href="https://golang.org/pkg/builtin/#uint32">uint32</a></pre>
			
			
			

		
			
			
			<h2 id="validateBinaryOperands">func <a href="https://golang.org/src/math/big/float.go?s=31598:31638#L1167">validateBinaryOperands</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#validateBinaryOperands">¶</a>
			</h2>
			<pre>func validateBinaryOperands(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
			
			
			

		
			
			
			<h2 id="writeMultiple">func <a href="https://golang.org/src/math/big/intconv.go?s=1289:1344#L36">writeMultiple</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#writeMultiple">¶</a>
			</h2>
			<pre>func writeMultiple(s <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#State">State</a>, text <a href="https://golang.org/pkg/builtin/#string">string</a>, count <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
			<p>
write count copies of text to s
</p>

			
			

		
		
			
			
			<h2 id="Accuracy">type <a href="https://golang.org/src/math/big/float.go?s=5519:5537#L131">Accuracy</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Accuracy">¶</a>
			</h2>
			<pre>type Accuracy <a href="https://golang.org/pkg/builtin/#int8">int8</a></pre>
			<p>
Accuracy describes the rounding error produced by the most recent
operation that generated a Float value, relative to the exact value.
</p>


			
				<pre>const (
        <span id="Below">Below</span> <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a> = -1
        <span id="Exact">Exact</span> <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a> = 0
        <span id="Above">Above</span> <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a> = +1
)</pre>
				<p>
Constants describing the Accuracy of a Float.
</p>

			

			

			
			
			

			
				
				<h3 id="makeAcc">func <a href="https://golang.org/src/math/big/float.go?s=6444:6477#L173">makeAcc</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#makeAcc">¶</a>
				</h3>
				<pre>func makeAcc(above <a href="https://golang.org/pkg/builtin/#bool">bool</a>) <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a></pre>
				
				
				
			

			
				
				<h3 id="Accuracy.String">func (Accuracy) <a href="https://golang.org/src/math/big/accuracy_string.go?s=171:204#L1">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Accuracy.String">¶</a>
				</h3>
				<pre>func (i <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ErrNaN">type <a href="https://golang.org/src/math/big/float.go?s=2893:2927#L60">ErrNaN</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#ErrNaN">¶</a>
			</h2>
			<pre>type ErrNaN struct {
        msg <a href="https://golang.org/pkg/builtin/#string">string</a>
}</pre>
			<p>
An ErrNaN panic is raised by a Float operation that would lead to
a NaN under IEEE-754 rules. An ErrNaN implements the error interface.
</p>


			

			

			
			
			

			

			
				
				<h3 id="ErrNaN.Error">func (ErrNaN) <a href="https://golang.org/src/math/big/float.go?s=2929:2961#L64">Error</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#ErrNaN.Error">¶</a>
				</h3>
				<pre>func (err <a href="https://golang.org/pkg/math/big/?m=all#ErrNaN">ErrNaN</a>) Error() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Float">type <a href="https://golang.org/src/math/big/float.go?s=2637:2749#L48">Float</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float">¶</a>
			</h2>
			<pre>type Float struct {
        prec <a href="https://golang.org/pkg/builtin/#uint32">uint32</a>
        mode <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a>
        acc  <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>
        form form
        neg  <a href="https://golang.org/pkg/builtin/#bool">bool</a>
        mant nat
        exp  <a href="https://golang.org/pkg/builtin/#int32">int32</a>
}</pre>
			<p>
A nonzero finite Float represents a multi-precision floating point number
</p>
<pre>sign × mantissa × 2**exponent
</pre>
<p>
with 0.5 &lt;= mantissa &lt; 1.0, and MinExp &lt;= exponent &lt;= MaxExp.
A Float may also be zero (+0, -0) or infinite (+Inf, -Inf).
All Floats are ordered, and the ordering of two Floats x and y
is defined by x.Cmp(y).
</p>
<p>
Each Float value also has a precision, rounding mode, and accuracy.
The precision is the maximum number of mantissa bits available to
represent the value. The rounding mode specifies how a result should
be rounded to fit into the mantissa bits, and accuracy describes the
rounding error with respect to the exact result.
</p>
<p>
Unless specified otherwise, all operations (including setters) that
specify a *Float variable for the result (usually via the receiver
with the exception of MantExp), round the numeric result according
to the precision and rounding mode of the result variable.
</p>
<p>
If the provided result precision is 0 (see below), it is set to the
precision of the argument with the largest precision value before any
rounding takes place, and the rounding mode remains unchanged. Thus,
uninitialized Floats provided as result arguments will have their
precision set to a reasonable value determined by the operands and
their mode is the zero value for RoundingMode (ToNearestEven).
</p>
<p>
By setting the desired precision to 24 or 53 and using matching rounding
mode (typically ToNearestEven), Float operations produce the same results
as the corresponding float32 or float64 IEEE-754 arithmetic for operands
that correspond to normal (i.e., not denormal) float32 or float64 numbers.
Exponent underflow and overflow lead to a 0 or an Infinity for different
values than IEEE-754 because Float exponents have a much larger range.
</p>
<p>
The zero (uninitialized) value for a Float is ready to use and represents
the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.
</p>


			

			

			
			
			

			
				
				<h3 id="NewFloat">func <a href="https://golang.org/src/math/big/float.go?s=3139:3170#L71">NewFloat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#NewFloat">¶</a>
				</h3>
				<pre>func NewFloat(x <a href="https://golang.org/pkg/builtin/#float64">float64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
NewFloat allocates and returns a new Float set to x,
with precision 53 and rounding mode ToNearestEven.
NewFloat panics with ErrNaN if x is a NaN.
</p>

				
				
			
				
				<h3 id="ParseFloat">func <a href="https://golang.org/src/math/big/floatconv.go?s=6935:7029#L263">ParseFloat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#ParseFloat">¶</a>
				</h3>
				<pre>func ParseFloat(s <a href="https://golang.org/pkg/builtin/#string">string</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>, prec <a href="https://golang.org/pkg/builtin/#uint">uint</a>, mode <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a>) (f *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>, b <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
ParseFloat is like f.Parse(s, base) with f set to the given precision
and rounding mode.
</p>

				
				
			

			
				
				<h3 id="Float.Abs">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=31351:31387#L1153">Abs</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Abs">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Abs(x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Abs sets z to the (possibly rounded) value |x| (the absolute value of x)
and returns z.
</p>

				
				
				
			
				
				<h3 id="Float.Acc">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=7444:7474#L211">Acc</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Acc">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Acc() <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a></pre>
				<p>
Acc returns the accuracy of x produced by the most recent operation.
</p>

				
				
				
			
				
				<h3 id="Float.Add">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=38828:38867#L1399">Add</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Add">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Add(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Add sets z to the rounded sum x+y and returns z. If z's precision is 0,
it is changed to the larger of x's or y's precision before the operation.
Rounding is performed according to z's precision and rounding mode; and
z's accuracy reports the result error relative to the exact (not rounded)
result. Add panics with ErrNaN if x and y are infinities with opposite
signs. The value of z is undefined in that case.
</p>
<p>
BUG(gri) When rounding ToNegativeInf, the sign of Float values rounded to 0 is incorrect.
</p>

				
				<div id="example_Float_Add" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

func main() {
	// Operating on numbers of different precision.
	var x, y, z big.Float
	x.SetInt64(1000)          // x is automatically set to 64bit precision
	y.SetFloat64(2.718281828) // y is automatically set to 53bit precision
	z.SetPrec(32)
	z.Add(&amp;x, &amp;y)
	fmt.Printf("x = %.10g (%s, prec = %d, acc = %s)\n", &amp;x, x.Text('p', 0), x.Prec(), x.Acc())
	fmt.Printf("y = %.10g (%s, prec = %d, acc = %s)\n", &amp;y, y.Text('p', 0), y.Prec(), y.Acc())
	fmt.Printf("z = %.10g (%s, prec = %d, acc = %s)\n", &amp;z, z.Text('p', 0), z.Prec(), z.Acc())
}
</textarea></div>
				<div class="output"><pre>x = 1000 (0x.fap+10, prec = 64, acc = Exact)
y = 2.718281828 (0x.adf85458248cd8p+2, prec = 53, acc = Exact)
z = 1002.718282 (0x.faadf854p+10, prec = 32, acc = Below)
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Float.Append">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=2243:2304#L49">Append</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Append">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Append(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, fmt <a href="https://golang.org/pkg/builtin/#byte">byte</a>, prec <a href="https://golang.org/pkg/builtin/#int">int</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
Append appends to buf the string form of the floating-point number x,
as generated by x.Text, and returns the extended buffer.
</p>

				
				
				
			
				
				<h3 id="Float.Cmp">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=43182:43215#L1617">Cmp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Cmp">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Cmp(y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Cmp compares x and y and returns:
</p>
<pre>-1 if x &lt;  y
 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)
+1 if x &gt;  y
</pre>

				
				<div id="example_Float_Cmp" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math"
	"math/big"
)

func main() {
	inf := math.Inf(1)
	zero := 0.0

	operands := []float64{-inf, -1.2, -zero, 0, +1.2, +inf}

	fmt.Println("   x     y  cmp")
	fmt.Println("---------------")
	for _, x64 := range operands {
		x := big.NewFloat(x64)
		for _, y64 := range operands {
			y := big.NewFloat(y64)
			fmt.Printf("%4g  %4g  %3d\n", x, y, x.Cmp(y))
		}
		fmt.Println()
	}

}
</textarea></div>
				<div class="output"><pre>   x     y  cmp
---------------
-Inf  -Inf    0
-Inf  -1.2   -1
-Inf    -0   -1
-Inf     0   -1
-Inf   1.2   -1
-Inf  +Inf   -1

-1.2  -Inf    1
-1.2  -1.2    0
-1.2    -0   -1
-1.2     0   -1
-1.2   1.2   -1
-1.2  +Inf   -1

  -0  -Inf    1
  -0  -1.2    1
  -0    -0    0
  -0     0    0
  -0   1.2   -1
  -0  +Inf   -1

   0  -Inf    1
   0  -1.2    1
   0    -0    0
   0     0    0
   0   1.2   -1
   0  +Inf   -1

 1.2  -Inf    1
 1.2  -1.2    1
 1.2    -0    1
 1.2     0    1
 1.2   1.2    0
 1.2  +Inf   -1

+Inf  -Inf    1
+Inf  -1.2    1
+Inf    -0    1
+Inf     0    1
+Inf   1.2    1
+Inf  +Inf    0
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Float.Copy">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=18333:18370#L649">Copy</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Copy">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Copy(x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Copy sets z to x, with the same precision, rounding mode, and
accuracy as x, and returns z. x is not changed even if z and
x are the same.
</p>

				
				
				
			
				
				<h3 id="Float.Float32">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=21739:21784#L812">Float32</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Float32">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Float32() (<a href="https://golang.org/pkg/builtin/#float32">float32</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Float32 returns the float32 value nearest to x. If x is too small to be
represented by a float32 (|x| &lt; math.SmallestNonzeroFloat32), the result
is (0, Below) or (-0, Above), respectively, depending on the sign of x.
If x is too large to be represented by a float32 (|x| &gt; math.MaxFloat32),
the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
</p>

				
				
				
			
				
				<h3 id="Float.Float64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=25592:25637#L932">Float64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Float64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Float64() (<a href="https://golang.org/pkg/builtin/#float64">float64</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Float64 returns the float64 value nearest to x. If x is too small to be
represented by a float64 (|x| &lt; math.SmallestNonzeroFloat64), the result
is (0, Below) or (-0, Above), respectively, depending on the sign of x.
If x is too large to be represented by a float64 (|x| &gt; math.MaxFloat64),
the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
</p>

				
				
				
			
				
				<h3 id="Float.Format">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=10338:10386#L378">Format</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Format">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Format(s <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#State">State</a>, format <a href="https://golang.org/pkg/builtin/#rune">rune</a>)</pre>
				<p>
Format implements fmt.Formatter. It accepts all the regular
formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
'g', 'G') as well as 'p' and 'v'. See (*Float).Text for the
interpretation of 'p'. The 'v' format is handled like 'g'.
Format also supports specification of the minimum precision
in digits, the output field width, as well as the format flags
'+' and ' ' for sign control, '0' for space or zero padding,
and '-' for left or right justification. See the fmt package
for details.
</p>

				
				
				
			
				
				<h3 id="Float.GobDecode">func (*Float) <a href="https://golang.org/src/math/big/floatmarsh.go?s=1926:1969#L54">GobDecode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.GobDecode">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) GobDecode(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
GobDecode implements the gob.GobDecoder interface.
The result is rounded per the precision and rounding mode of
z unless z's precision is 0, in which case z is set exactly
to the decoded value.
</p>

				
				
				
			
				
				<h3 id="Float.GobEncode">func (*Float) <a href="https://golang.org/src/math/big/floatmarsh.go?s=524:567#L10">GobEncode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.GobEncode">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) GobEncode() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
GobEncode implements the gob.GobEncoder interface.
The Float value and all its attributes (precision,
rounding mode, accuracy) are marshalled.
</p>

				
				
				
			
				
				<h3 id="Float.Int">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=29318:29362#L1053">Int</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Int">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Int(z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Int returns the result of truncating x towards zero;
or nil if x is an infinity.
The result is Exact if x.IsInt(); otherwise it is Below
for x &gt; 0, and Above for x &lt; 0.
If a non-nil *Int argument z is provided, Int stores
the result in z instead of allocating a new Int.
</p>

				
				
				
			
				
				<h3 id="Float.Int64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=20470:20511#L757">Int64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Int64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Int64() (<a href="https://golang.org/pkg/builtin/#int64">int64</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Int64 returns the integer resulting from truncating x towards zero.
If math.MinInt64 &lt;= x &lt;= math.MaxInt64, the result is Exact if x is
an integer, and Above (x &lt; 0) or Below (x &gt; 0) otherwise.
The result is (math.MinInt64, Above) for x &lt; math.MinInt64,
and (math.MaxInt64, Below) for x &gt; math.MaxInt64.
</p>

				
				
				
			
				
				<h3 id="Float.IsInf">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=9686:9714#L319">IsInf</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.IsInf">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) IsInf() <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
IsInf reports whether x is +Inf or -Inf.
</p>

				
				
				
			
				
				<h3 id="Float.IsInt">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=9818:9846#L325">IsInt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.IsInt">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) IsInt() <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
IsInt reports whether x is an integer.
±Inf values are not integers.
</p>

				
				
				
			
				
				<h3 id="Float.MantExp">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=8319:8365#L249">MantExp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.MantExp">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) MantExp(mant *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) (exp <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
MantExp breaks x into its mantissa and exponent components
and returns the exponent. If a non-nil mant argument is
provided its value is set to the mantissa of x, with the
same precision and rounding mode as x. The components
satisfy x == mant × 2**exp, with 0.5 &lt;= |mant| &lt; 1.0.
Calling MantExp with a nil argument is an efficient way to
get the exponent of the receiver.
</p>
<p>
Special cases are:
</p>
<pre>(  ±0).MantExp(mant) = 0, with mant set to   ±0
(±Inf).MantExp(mant) = 0, with mant set to ±Inf
</pre>
<p>
x and mant may be the same in which case x is set to its
mantissa value.
</p>

				
				
				
			
				
				<h3 id="Float.MarshalText">func (*Float) <a href="https://golang.org/src/math/big/floatmarsh.go?s=2782:2836#L91">MarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.MarshalText">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) MarshalText() (text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
MarshalText implements the encoding.TextMarshaler interface.
Only the Float value is marshaled (in full precision), other
attributes such as precision or accuracy are ignored.
</p>

				
				
				
			
				
				<h3 id="Float.MinPrec">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=7146:7176#L198">MinPrec</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.MinPrec">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) MinPrec() <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
MinPrec returns the minimum precision required to represent x exactly
(i.e., the smallest prec before x.SetPrec(prec) would start rounding x).
The result is 0 for |x| == 0 and |x| == Inf.
</p>

				
				
				
			
				
				<h3 id="Float.Mode">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=7316:7351#L206">Mode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Mode">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Mode() <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a></pre>
				<p>
Mode returns the rounding mode of x.
</p>

				
				
				
			
				
				<h3 id="Float.Mul">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=41414:41453#L1525">Mul</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Mul">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Mul(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Mul sets z to the rounded product x*y and returns z.
Precision, rounding, and accuracy reporting are as for Add.
Mul panics with ErrNaN if one operand is zero and the other
operand an infinity. The value of z is undefined in that case.
</p>

				
				
				
			
				
				<h3 id="Float.Neg">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=31520:31556#L1161">Neg</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Neg">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Neg(x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Neg sets z to the (possibly rounded) value of x with its sign negated,
and returns z.
</p>

				
				
				
			
				
				<h3 id="Float.Parse">func (*Float) <a href="https://golang.org/src/math/big/floatconv.go?s=6239:6309#L235">Parse</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Parse">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Parse(s <a href="https://golang.org/pkg/builtin/#string">string</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) (f *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>, b <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
Parse parses s which must contain a text representation of a floating-
point number with a mantissa in the given conversion base (the exponent
is always a decimal number), or a string representing an infinite value.
</p>
<p>
It sets z to the (possibly rounded) value of the corresponding floating-
point value, and returns z, the actual base b, and an error err, if any.
If z's precision is 0, it is changed to 64 before rounding takes effect.
The number must be of the form:
</p>
<pre>	number   = [ sign ] [ prefix ] mantissa [ exponent ] | infinity .
	sign     = "+" | "-" .
     prefix   = "0" ( "x" | "X" | "b" | "B" ) .
	mantissa = digits | digits "." [ digits ] | "." digits .
	exponent = ( "E" | "e" | "p" ) [ sign ] digits .
	digits   = digit { digit } .
	digit    = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
     infinity = [ sign ] ( "inf" | "Inf" ) .
</pre>
<p>
The base argument must be 0, 2, 10, or 16. Providing an invalid base
argument will lead to a run-time panic.
</p>
<p>
For base 0, the number prefix determines the actual base: A prefix of
"0x" or "0X" selects base 16, and a "0b" or "0B" prefix selects
base 2; otherwise, the actual base is 10 and no prefix is accepted.
The octal prefix "0" is not supported (a leading "0" is simply
considered a "0").
</p>
<p>
A "p" exponent indicates a binary (rather then decimal) exponent;
for instance "0x1.fffffffffffffp1023" (using base 0) represents the
maximum float64 value. For hexadecimal mantissae, the exponent must
be binary, if present (an "e" or "E" exponent indicator cannot be
distinguished from a mantissa digit).
</p>
<p>
The returned *Float f is nil and the value of z is valid but not
defined if an error is reported.
</p>

				
				
				
			
				
				<h3 id="Float.Prec">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=6895:6922#L191">Prec</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Prec">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Prec() <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
Prec returns the mantissa precision of x in bits.
The result may be 0 for |x| == 0 and |x| == Inf.
</p>

				
				
				
			
				
				<h3 id="Float.Quo">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=42335:42374#L1570">Quo</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Quo">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Quo(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Quo sets z to the rounded quotient x/y and returns z.
Precision, rounding, and accuracy reporting are as for Add.
Quo panics with ErrNaN if both operands are zero or infinities.
The value of z is undefined in that case.
</p>

				
				
				
			
				
				<h3 id="Float.Rat">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=30417:30461#L1109">Rat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Rat">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Rat(z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Rat returns the rational number corresponding to x;
or nil if x is an infinity.
The result is Exact if x is not an Inf.
If a non-nil *Rat argument z is provided, Rat stores
the result in z instead of allocating a new Rat.
</p>

				
				
				
			
				
				<h3 id="Float.Set">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=17871:17907#L625">Set</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Set">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Set(x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Set sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the precision of x
before setting z (and rounding will have no effect).
Rounding is performed according to z's precision and rounding
mode; and z's accuracy reports the result error relative to the
exact (not rounded) result.
</p>

				
				
				
			
				
				<h3 id="Float.SetFloat64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=15234:15278#L523">SetFloat64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetFloat64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetFloat64(x <a href="https://golang.org/pkg/builtin/#float64">float64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetFloat64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 53 (and rounding will have
no effect). SetFloat64 panics with ErrNaN if x is a NaN.
</p>

				
				
				
			
				
				<h3 id="Float.SetInf">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=17419:17462#L612">SetInf</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetInf">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetInf(signbit <a href="https://golang.org/pkg/builtin/#bool">bool</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetInf sets z to the infinite Float -Inf if signbit is
set, or +Inf if signbit is not set, and returns z. The
precision of z is unchanged and the result is always
Exact.
</p>

				
				
				
			
				
				<h3 id="Float.SetInt">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=16410:16447#L571">SetInt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetInt">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetInt(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetInt sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the larger of x.BitLen()
or 64 (and rounding will have no effect).
</p>

				
				
				
			
				
				<h3 id="Float.SetInt64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=14796:14836#L510">SetInt64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetInt64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetInt64(x <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetInt64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 64 (and rounding will have
no effect).
</p>

				
				
				
			
				
				<h3 id="Float.SetMantExp">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=9312:9367#L300">SetMantExp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetMantExp">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetMantExp(mant *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>, exp <a href="https://golang.org/pkg/builtin/#int">int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetMantExp sets z to mant × 2**exp and and returns z.
The result z has the same precision and rounding mode
as mant. SetMantExp is an inverse of MantExp but does
not require 0.5 &lt;= |mant| &lt; 1.0. Specifically:
</p>
<pre>mant := new(Float)
new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0
</pre>
<p>
Special cases are:
</p>
<pre>z.SetMantExp(  ±0, exp) =   ±0
z.SetMantExp(±Inf, exp) = ±Inf
</pre>
<p>
z and mant may be the same in which case z's exponent
is set to exp.
</p>

				
				
				
			
				
				<h3 id="Float.SetMode">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=6695:6744#L183">SetMode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetMode">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetMode(mode <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetMode sets z's rounding mode to mode and returns an exact z.
z remains unchanged otherwise.
z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.
</p>

				
				
				
			
				
				<h3 id="Float.SetPrec">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=6039:6080#L147">SetPrec</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetPrec">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetPrec(prec <a href="https://golang.org/pkg/builtin/#uint">uint</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetPrec sets z's precision to prec and returns the (possibly) rounded
value of z. Rounding occurs according to z's rounding mode if the mantissa
cannot be represented in prec bits without loss of precision.
SetPrec(0) maps all finite values to ±0; infinite values remain unchanged.
If prec &gt; MaxPrec, it is set to MaxPrec.
</p>

				
				
				
			
				
				<h3 id="Float.SetRat">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=17015:17052#L595">SetRat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetRat">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetRat(x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetRat sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to the largest of a.BitLen(),
b.BitLen(), or 64; with x = a/b.
</p>

				
				
				
			
				
				<h3 id="Float.SetString">func (*Float) <a href="https://golang.org/src/math/big/floatconv.go?s=461:511#L8">SetString</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetString">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetString(s <a href="https://golang.org/pkg/builtin/#string">string</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>, <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetString sets z to the value of s and returns z and a boolean indicating
success. s must be a floating-point number of the same format as accepted
by Parse, with base argument 0.
</p>

				
				
				
			
				
				<h3 id="Float.SetUint64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=14562:14604#L503">SetUint64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.SetUint64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) SetUint64(x <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
SetUint64 sets z to the (possibly rounded) value of x and returns z.
If z's precision is 0, it is changed to 64 (and rounding will have
no effect).
</p>

				
				
				
			
				
				<h3 id="Float.Sign">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=7569:7595#L221">Sign</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Sign">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Sign() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Sign returns:
</p>
<pre>-1 if x &lt;   0
 0 if x is ±0
+1 if x &gt;   0
</pre>

				
				
				
			
				
				<h3 id="Float.Signbit">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=9592:9622#L314">Signbit</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Signbit">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Signbit() <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
Signbit returns true if x is negative or negative zero.
</p>

				
				
				
			
				
				<h3 id="Float.String">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=2049:2080#L43">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.String">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
String formats x like x.Text('g', 10).
(String must be called explicitly, Float.Format does not support %s verb.)
</p>

				
				
				
			
				
				<h3 id="Float.Sub">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=40115:40154#L1462">Sub</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Sub">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Sub(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
Sub sets z to the rounded difference x-y and returns z.
Precision, rounding, and accuracy reporting are as for Add.
Sub panics with ErrNaN if x and y are infinities with equal
signs. The value of z is undefined in that case.
</p>

				
				
				
			
				
				<h3 id="Float.Text">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=1721:1771#L33">Text</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Text">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Text(format <a href="https://golang.org/pkg/builtin/#byte">byte</a>, prec <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
Text converts the floating-point number x to a string according
to the given format and precision prec. The format is one of:
</p>
<pre>'e'	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
'E'	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
'f'	-ddddd.dddd, no exponent
'g'	like 'e' for large exponents, like 'f' otherwise
'G'	like 'E' for large exponents, like 'f' otherwise
'b'	-ddddddp±dd, binary exponent
'p'	-0x.dddp±dd, binary exponent, hexadecimal mantissa
</pre>
<p>
For the binary exponent formats, the mantissa is printed in normalized form:
</p>
<pre>'b'	decimal integer mantissa using x.Prec() bits, or -0
'p'	hexadecimal fraction with 0.5 &lt;= 0.mantissa &lt; 1.0, or -0
</pre>
<p>
If format is a different character, Text returns a "%" followed by the
unrecognized format character.
</p>
<p>
The precision prec controls the number of digits (excluding the exponent)
printed by the 'e', 'E', 'f', 'g', and 'G' formats. For 'e', 'E', and 'f'
it is the number of digits after the decimal point. For 'g' and 'G' it is
the total number of digits. A negative precision selects the smallest
number of decimal digits necessary to identify the value x uniquely using
x.Prec() mantissa bits.
The prec value is ignored for the 'b' or 'p' format.
</p>

				
				
				
			
				
				<h3 id="Float.Uint64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=19530:19573#L712">Uint64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.Uint64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) Uint64() (<a href="https://golang.org/pkg/builtin/#uint64">uint64</a>, <a href="https://golang.org/pkg/math/big/?m=all#Accuracy">Accuracy</a>)</pre>
				<p>
Uint64 returns the unsigned integer resulting from truncating x
towards zero. If 0 &lt;= x &lt;= math.MaxUint64, the result is Exact
if x is an integer and Below otherwise.
The result is (0, Above) for x &lt; 0, and (math.MaxUint64, Below)
for x &gt; math.MaxUint64.
</p>

				
				
				
			
				
				<h3 id="Float.UnmarshalText">func (*Float) <a href="https://golang.org/src/math/big/floatmarsh.go?s=3156:3204#L103">UnmarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.UnmarshalText">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) UnmarshalText(text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
UnmarshalText implements the encoding.TextUnmarshaler interface.
The result is rounded per the precision and rounding mode of z.
If z's precision is 0, it is changed to 64 before rounding takes
effect.
</p>

				
				
				
			
				
				<h3 id="Float.fmtB">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=8342:8381#L301">fmtB</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.fmtB">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) fmtB(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
fmtB appends the string of x in the format mantissa "p" exponent
with a decimal mantissa and a binary exponent, or 0" if x is zero,
and returns the extended buffer.
The mantissa is normalized such that is uses x.Prec() bits in binary
representation.
The sign of x is ignored, and x must not be an Inf.
</p>

				
				
				
			
				
				<h3 id="Float.fmtP">func (*Float) <a href="https://golang.org/src/math/big/ftoa.go?s=9212:9251#L334">fmtP</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.fmtP">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) fmtP(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
fmtP appends the string of x in the format "0x." mantissa "p" exponent
with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
and returns the extended buffer.
The mantissa is normalized such that 0.5 &lt;= 0.mantissa &lt; 1.0.
The sign of x is ignored, and x must not be an Inf.
</p>

				
				
				
			
				
				<h3 id="Float.ord">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=43681:43706#L1652">ord</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.ord">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) ord() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
ord classifies x and returns:
</p>
<pre>-2 if -Inf == x
-1 if -Inf &lt; x &lt; 0
 0 if x == 0 (signed or unsigned)
+1 if 0 &lt; x &lt; +Inf
+2 if x == +Inf
</pre>

				
				
				
			
				
				<h3 id="Float.pow5">func (*Float) <a href="https://golang.org/src/math/big/floatconv.go?s=4109:4146#L174">pow5</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.pow5">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) pow5(n <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				<p>
pow5 sets z to 5**n and returns z.
n must not be negative.
</p>

				
				
				
			
				
				<h3 id="Float.round">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=11045:11077#L371">round</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.round">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) round(sbit <a href="https://golang.org/pkg/builtin/#uint">uint</a>)</pre>
				<p>
round rounds z according to z.mode to z.prec bits and sets z.acc accordingly.
sbit must be 0 or 1 and summarizes any "sticky bit" information one might
have before calling round. z's mantissa must be normalized (with the msb set)
or empty.
</p>
<p>
CAUTION: The rounding modes ToNegativeInf, ToPositiveInf are affected by the
sign of z. For correct rounding, the sign of z must be set correctly before
calling round.
</p>

				
				
				
			
				
				<h3 id="Float.scan">func (*Float) <a href="https://golang.org/src/math/big/floatconv.go?s=864:941#L19">scan</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.scan">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) scan(r <a href="https://golang.org/pkg/io/">io</a>.<a href="https://golang.org/pkg/io/#ByteScanner">ByteScanner</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) (f *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>, b <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
scan is like Parse but reads the longest possible prefix representing a valid
floating point number from an io.ByteScanner rather than a string. It serves
as the implementation of Parse. It does not recognize ±Inf and does not expect
EOF at the end.
</p>

				
				
				
			
				
				<h3 id="Float.setBits64">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=14081:14133#L479">setBits64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.setBits64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) setBits64(neg <a href="https://golang.org/pkg/builtin/#bool">bool</a>, x <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a></pre>
				
				
				
				
			
				
				<h3 id="Float.setExpAndRound">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=8542:8594#L265">setExpAndRound</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.setExpAndRound">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) setExpAndRound(exp <a href="https://golang.org/pkg/builtin/#int64">int64</a>, sbit <a href="https://golang.org/pkg/builtin/#uint">uint</a>)</pre>
				
				
				
				
			
				
				<h3 id="Float.uadd">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=32047:32080#L1183">uadd</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.uadd">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) uadd(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
				<p>
z = x + y, ignoring signs of x and y for the addition
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.
</p>

				
				
				
			
				
				<h3 id="Float.ucmp">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=36784:36818#L1335">ucmp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.ucmp">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) ucmp(y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
ucmp returns -1, 0, or +1, depending on whether
|x| &lt; |y|, |x| == |y|, or |x| &gt; |y|.
x and y must have a non-empty mantissa and valid exponent.
</p>

				
				
				
			
				
				<h3 id="Float.umul">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=34729:34762#L1270">umul</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.umul">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) umul(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
				<p>
z = x * y, ignoring signs of x and y for the multiplication
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.
</p>

				
				
				
			
				
				<h3 id="Float.uquo">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=35344:35377#L1290">uquo</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.uquo">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) uquo(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
				<p>
z = x / y, ignoring signs of x and y for the division
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.
</p>

				
				
				
			
				
				<h3 id="Float.usub">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=33597:33630#L1227">usub</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.usub">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) usub(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>)</pre>
				<p>
z = x - y for |x| &gt; |y|, ignoring signs of x and y for the subtraction
but using the sign of z for rounding the result.
x and y must have a non-empty mantissa and valid exponent.
</p>

				
				
				
			
				
				<h3 id="Float.validate">func (*Float) <a href="https://golang.org/src/math/big/float.go?s=10151:10177#L342">validate</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Float.validate">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Float">Float</a>) validate()</pre>
				<p>
debugging support
</p>

				
				
				
			
		
			
			
			<h2 id="Int">type <a href="https://golang.org/src/math/big/int.go?s=388:468#L8">Int</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int">¶</a>
			</h2>
			<pre>type Int struct {
        neg <a href="https://golang.org/pkg/builtin/#bool">bool</a> <span class="comment">// sign</span>
        abs nat  <span class="comment">// absolute value of the integer</span>
}</pre>
			<p>
An Int represents a signed multi-precision integer.
The zero value for an Int represents the value 0.
</p>


			

			

			
			
			

			
				
				<h3 id="NewInt">func <a href="https://golang.org/src/math/big/int.go?s=1058:1083#L51">NewInt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#NewInt">¶</a>
				</h3>
				<pre>func NewInt(x <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
NewInt allocates and returns a new Int set to x.
</p>

				
				
			
				
				<h3 id="scaleDenom">func <a href="https://golang.org/src/math/big/rat.go?s=11406:11441#L443">scaleDenom</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#scaleDenom">¶</a>
				</h3>
				<pre>func scaleDenom(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, f nat) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
scaleDenom computes x*f.
If f == 0 (zero value of denominator), the result is (a copy of) x.
</p>

				
				
			

			
				
				<h3 id="Int.Abs">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=2124:2154#L85">Abs</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Abs">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Abs(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Abs sets z to |x| (the absolute value of x) and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Add">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=2381:2414#L99">Add</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Add">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Add(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Add sets z to the sum x+y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.And">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=18694:18727#L789">And</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.And">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) And(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
And sets z = x &amp; y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.AndNot">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=19375:19411#L819">AndNot</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.AndNot">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) AndNot(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
AndNot sets z = x &amp;^ y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Append">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=1046:1095#L24">Append</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Append">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Append(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
Append appends the string representation of x, as generated by
x.Text(base), to buf and returns the extended buffer.
</p>

				
				
				
			
				
				<h3 id="Int.Binomial">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=4127:4166#L175">Binomial</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Binomial">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Binomial(n, k <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Binomial sets z to the binomial coefficient of (n, k) and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Bit">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=17806:17835#L749">Bit</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Bit">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Bit(i <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
Bit returns the value of the i'th bit of x. That is, it
returns (x&gt;&gt;i)&amp;1. The bit index i must be &gt;= 0.
</p>

				
				
				
			
				
				<h3 id="Int.BitLen">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=9739:9765#L391">BitLen</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.BitLen">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) BitLen() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
BitLen returns the length of the absolute value of x in bits.
The bit length of 0 is 0.
</p>

				
				
				
			
				
				<h3 id="Int.Bits">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=1572:1599#L69">Bits</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Bits">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Bits() []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a></pre>
				<p>
Bits provides raw (unchecked but fast) access to x by returning its
absolute value as a little-endian Word slice. The result and x share
the same underlying array.
Bits is intended to support implementation of missing low-level Int
functionality outside this package; it should be avoided otherwise.
</p>

				
				
				
			
				
				<h3 id="Int.Bytes">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=9544:9572#L384">Bytes</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Bytes">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Bytes() []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
Bytes returns the absolute value of x as a big-endian byte slice.
</p>

				
				
				
			
				
				<h3 id="Int.Cmp">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=7472:7505#L298">Cmp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Cmp">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Cmp(y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) (r <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
Cmp compares x and y and returns:
</p>
<pre>-1 if x &lt;  y
 0 if x == y
+1 if x &gt;  y
</pre>

				
				
				
			
				
				<h3 id="Int.Div">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=5888:5921#L225">Div</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Div">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Div(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Div sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Div implements Euclidean division (unlike Go); see DivMod for more details.
</p>

				
				
				
			
				
				<h3 id="Int.DivMod">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=7093:7140#L274">DivMod</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.DivMod">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) DivMod(x, y, m *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>)</pre>
				<p>
DivMod sets z to the quotient x div y and m to the modulus x mod y
and returns the pair (z, m) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
</p>
<p>
DivMod implements Euclidean division and modulus (unlike Go):
</p>
<pre>q = x div y  such that
m = x - y*q  with 0 &lt;= m &lt; |y|
</pre>
<p>
(See Raymond T. Boute, “The Euclidean definition of the functions
div and mod”. ACM Transactions on Programming Languages and
Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
ACM press.)
See QuoRem for T-division and modulus (like Go).
</p>

				
				
				
			
				
				<h3 id="Int.Exp">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=9982:10018#L398">Exp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Exp">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Exp(x, y, m *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
If y &lt;= 0, the result is 1 mod |m|; if m == nil or m == 0, z = x**y.
See Knuth, volume 2, section 4.6.3.
</p>

				
				
				
			
				
				<h3 id="Int.Format">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=1992:2034#L56">Format</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Format">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Format(s <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#State">State</a>, ch <a href="https://golang.org/pkg/builtin/#rune">rune</a>)</pre>
				<p>
Format implements fmt.Formatter. It accepts the formats
'b' (binary), 'o' (octal), 'd' (decimal), 'x' (lowercase
hexadecimal), and 'X' (uppercase hexadecimal).
Also supported are the full suite of package fmt's format
flags for integral types, including '+' and ' ' for sign
control, '#' for leading zero in octal and for hexadecimal,
a leading "0x" or "0X" for "%#x" and "%#X" respectively,
specification of minimum digits precision, output field
width, space or zero padding, and '-' for left or right
justification.
</p>

				
				
				
			
				
				<h3 id="Int.GCD">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=10689:10728#L425">GCD</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.GCD">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) GCD(x, y, a, b *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
GCD sets z to the greatest common divisor of a and b, which both must
be &gt; 0, and returns z.
If x and y are not nil, GCD sets x and y such that z = a*x + b*y.
If either a or b is &lt;= 0, GCD sets z = x = y = 0.
</p>

				
				
				
			
				
				<h3 id="Int.GobDecode">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=782:823#L20">GobDecode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.GobDecode">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) GobDecode(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
GobDecode implements the gob.GobDecoder interface.
</p>

				
				
				
			
				
				<h3 id="Int.GobEncode">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=398:439#L5">GobEncode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.GobEncode">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) GobEncode() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
GobEncode implements the gob.GobEncoder interface.
</p>

				
				
				
			
				
				<h3 id="Int.Int64">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=8193:8220#L339">Int64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Int64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Int64() <a href="https://golang.org/pkg/builtin/#int64">int64</a></pre>
				<p>
Int64 returns the int64 representation of x.
If x cannot be represented in an int64, the result is undefined.
</p>

				
				
				
			
				
				<h3 id="Int.Lsh">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=17204:17242#L725">Lsh</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Lsh">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Lsh(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, n <a href="https://golang.org/pkg/builtin/#uint">uint</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Lsh sets z = x &lt;&lt; n and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.MarshalJSON">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=1859:1902#L57">MarshalJSON</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.MarshalJSON">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) MarshalJSON() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
MarshalJSON implements the json.Marshaler interface.
</p>

				
				
				
			
				
				<h3 id="Int.MarshalText">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=1172:1224#L36">MarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.MarshalText">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) MarshalText() (text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
MarshalText implements the encoding.TextMarshaler interface.
</p>

				
				
				
			
				
				<h3 id="Int.Mod">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=6287:6320#L242">Mod</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Mod">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Mod(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Mod sets z to the modulus x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Mod implements Euclidean modulus (unlike Go); see DivMod for more details.
</p>

				
				
				
			
				
				<h3 id="Int.ModInverse">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=13523:13563#L569">ModInverse</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.ModInverse">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) ModInverse(g, n *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ
and returns z. If g and n are not relatively prime, the result is undefined.
</p>

				
				
				
			
				
				<h3 id="Int.ModSqrt">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=16679:16716#L703">ModSqrt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.ModSqrt">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) ModSqrt(x, p *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
ModSqrt sets z to a square root of x mod p if such a square root exists, and
returns z. The modulus p must be an odd prime. If x is not a square mod p,
ModSqrt leaves z unchanged and returns nil. This function panics if p is
not an odd integer.
</p>

				
				
				
			
				
				<h3 id="Int.Mul">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=3332:3365#L141">Mul</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Mul">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Mul(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Mul sets z to the product x*y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.MulRange">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=3711:3750#L154">MulRange</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.MulRange">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) MulRange(a, b <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
MulRange sets z to the product of all integers
in the range [a, b] inclusively and returns z.
If a &gt; b (empty range), the result is 1.
</p>

				
				
				
			
				
				<h3 id="Int.Neg">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=2230:2260#L92">Neg</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Neg">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Neg(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Neg sets z to -x and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Not">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=21636:21666#L912">Not</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Not">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Not(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Not sets z = ^x and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Or">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=20189:20221#L852">Or</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Or">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Or(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Or sets z = x | y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.ProbablyPrime">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=12959:12998#L549">ProbablyPrime</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.ProbablyPrime">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) ProbablyPrime(n <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
ProbablyPrime performs n Miller-Rabin tests to check whether x is prime.
If x is prime, it returns true.
If x is not prime, it returns false with probability at least 1 - ¼ⁿ.
</p>
<p>
It is not suitable for judging primes that an adversary may have crafted
to fool this test.
</p>

				
				
				
			
				
				<h3 id="Int.Quo">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=4573:4606#L189">Quo</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Quo">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Quo(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Quo sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Quo implements truncated division (like Go); see QuoRem for more details.
</p>

				
				
				
			
				
				<h3 id="Int.QuoRem">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=5489:5536#L216">QuoRem</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.QuoRem">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) QuoRem(x, y, r *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>)</pre>
				<p>
QuoRem sets z to the quotient x/y and r to the remainder x%y
and returns the pair (z, r) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
</p>
<p>
QuoRem implements T-division and modulus (like Go):
</p>
<pre>q = x/y      with the result truncated to zero
r = x - y*q
</pre>
<p>
(See Daan Leijen, “Division and Modulus for Computer Scientists”.)
See DivMod for Euclidean division and modulus (unlike Go).
</p>

				
				
				
			
				
				<h3 id="Int.Rand">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=13171:13218#L557">Rand</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Rand">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Rand(rnd *<a href="https://golang.org/pkg/math/rand/">rand</a>.<a href="https://golang.org/pkg/math/rand/#Rand">Rand</a>, n *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Rand sets z to a pseudo-random number in [0, n) and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Rem">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=4915:4948#L198">Rem</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Rem">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Rem(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Rem sets z to the remainder x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Rem implements truncated modulus (like Go); see QuoRem for more details.
</p>

				
				
				
			
				
				<h3 id="Int.Rsh">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=17340:17378#L732">Rsh</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Rsh">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Rsh(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, n <a href="https://golang.org/pkg/builtin/#uint">uint</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Rsh sets z = x &gt;&gt; n and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Scan">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=6286:6336#L219">Scan</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Scan">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Scan(s <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#ScanState">ScanState</a>, ch <a href="https://golang.org/pkg/builtin/#rune">rune</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
Scan is a support routine for fmt.Scanner; it sets z to the value of
the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).
</p>

				
				<div id="example_Int_Scan" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"log"
	"math/big"
)

func main() {
	// The Scan function is rarely used directly;
	// the fmt package recognizes it as an implementation of fmt.Scanner.
	i := new(big.Int)
	_, err := fmt.Sscan("18446744073709551617", i)
	if err != nil {
		log.Println("error scanning value:", err)
	} else {
		fmt.Println(i)
	}
}
</textarea></div>
				<div class="output"><pre>18446744073709551617
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Int.Set">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=1152:1182#L56">Set</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Set">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Set(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Set sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.SetBit">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=18350:18398#L772">SetBit</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetBit">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetBit(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, i <a href="https://golang.org/pkg/builtin/#int">int</a>, b <a href="https://golang.org/pkg/builtin/#uint">uint</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
SetBit sets z to x, with x's i'th bit set to b (0 or 1).
That is, if b is 1 SetBit sets z = x | (1 &lt;&lt; i);
if b is 0 SetBit sets z = x &amp;^ (1 &lt;&lt; i). If b is not 0 or 1,
SetBit will panic.
</p>

				
				
				
			
				
				<h3 id="Int.SetBits">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=1968:2006#L78">SetBits</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetBits">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetBits(abs []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
SetBits provides raw (unchecked but fast) access to z by setting its
value to abs, interpreted as a little-endian Word slice, and returning
z. The result and abs share the same underlying array.
SetBits is intended to support implementation of missing low-level Int
functionality outside this package; it should be avoided otherwise.
</p>

				
				
				
			
				
				<h3 id="Int.SetBytes">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=9376:9415#L377">SetBytes</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetBytes">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetBytes(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
SetBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.SetInt64">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=717:753#L32">SetInt64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetInt64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetInt64(x <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
SetInt64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.SetString">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=8978:9034#L362">SetString</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetString">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetString(s <a href="https://golang.org/pkg/builtin/#string">string</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetString sets z to the value of s, interpreted in the given base,
and returns z and a boolean indicating success. If SetString fails,
the value of z is undefined but the returned value is nil.
</p>
<p>
The base argument must be 0 or a value between 2 and MaxBase. If the base
is 0, the string prefix determines the actual conversion base. A prefix of
“0x” or “0X” selects base 16; the “0” prefix selects base 8, and a
“0b” or “0B” prefix selects base 2. Otherwise the selected base is 10.
</p>

				
				<div id="example_Int_SetString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

func main() {
	i := new(big.Int)
	i.SetString("644", 8) // octal
	fmt.Println(i)
}
</textarea></div>
				<div class="output"><pre>420
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Int.SetUint64">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=909:947#L44">SetUint64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.SetUint64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) SetUint64(x <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
SetUint64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Sign">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=575:599#L21">Sign</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Sign">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Sign() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Sign returns:
</p>
<pre>-1 if x &lt;  0
 0 if x == 0
+1 if x &gt;  0
</pre>

				
				
				
			
				
				<h3 id="Int.String">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=1200:1229#L31">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.String">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Int.Sub">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=2858:2891#L120">Sub</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Sub">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Sub(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Sub sets z to the difference x-y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.Text">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=807:842#L15">Text</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Text">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Text(base <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
Text returns the string representation of x in the given base.
Base must be between 2 and 36, inclusive. The result uses the
lower-case letters 'a' to 'z' for digit values &gt;= 10. No base
prefix (such as "0x") is added to the string.
</p>

				
				
				
			
				
				<h3 id="Int.Uint64">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=8404:8433#L349">Uint64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Uint64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Uint64() <a href="https://golang.org/pkg/builtin/#uint64">uint64</a></pre>
				<p>
Uint64 returns the uint64 representation of x.
If x cannot be represented in a uint64, the result is undefined.
</p>

				
				
				
			
				
				<h3 id="Int.UnmarshalJSON">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=1992:2038#L62">UnmarshalJSON</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.UnmarshalJSON">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) UnmarshalJSON(text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
UnmarshalJSON implements the json.Unmarshaler interface.
</p>

				
				
				
			
				
				<h3 id="Int.UnmarshalText">func (*Int) <a href="https://golang.org/src/math/big/intmarsh.go?s=1381:1427#L44">UnmarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.UnmarshalText">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) UnmarshalText(text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
UnmarshalText implements the encoding.TextUnmarshaler interface.
</p>

				
				
				
			
				
				<h3 id="Int.Xor">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=20959:20992#L882">Xor</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.Xor">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) Xor(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Xor sets z = x ^ y and returns z.
</p>

				
				
				
			
				
				<h3 id="Int.binaryGCD">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=11632:11671#L486">binaryGCD</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.binaryGCD">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) binaryGCD(a, b *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
binaryGCD sets z to the greatest common divisor of a and b, which both must
be &gt; 0, and returns z.
See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm B.
</p>

				
				
				
			
				
				<h3 id="Int.modSqrt3Mod4Prime">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=15023:15070#L642">modSqrt3Mod4Prime</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.modSqrt3Mod4Prime">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) modSqrt3Mod4Prime(x, p *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
modSqrt3Mod4 uses the identity
</p>
<pre>   (a^((p+1)/4))^2  mod p
== u^(p+1)          mod p
== u^2              mod p
</pre>
<p>
to calculate the square root of any quadratic residue mod p quickly for 3
mod 4 primes.
</p>

				
				
				
			
				
				<h3 id="Int.modSqrtTonelliShanks">func (*Int) <a href="https://golang.org/src/math/big/int.go?s=15342:15392#L652">modSqrtTonelliShanks</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.modSqrtTonelliShanks">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) modSqrtTonelliShanks(x, p *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
modSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square
root of a quadratic residue modulo any prime.
</p>

				
				
				
			
				
				<h3 id="Int.scan">func (*Int) <a href="https://golang.org/src/math/big/intconv.go?s=5089:5154#L165">scan</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Int.scan">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) scan(r <a href="https://golang.org/pkg/io/">io</a>.<a href="https://golang.org/pkg/io/#ByteScanner">ByteScanner</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>, <a href="https://golang.org/pkg/builtin/#int">int</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
scan sets z to the integer value corresponding to the longest possible prefix
read from r representing a signed integer number in a given conversion base.
It returns z, the actual conversion base used, and an error, if any. In the
error case, the value of z is undefined but the returned value is nil. The
syntax follows the syntax of integer literals in Go.
</p>
<p>
The base argument must be 0 or a value from 2 through MaxBase. If the base
is 0, the string prefix determines the actual conversion base. A prefix of
“0x” or “0X” selects base 16; the “0” prefix selects base 8, and a
“0b” or “0B” prefix selects base 2. Otherwise the selected base is 10.
</p>

				
				
				
			
		
			
			
			<h2 id="Rat">type <a href="https://golang.org/src/math/big/rat.go?s=370:570#L6">Rat</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat">¶</a>
			</h2>
			<pre>type Rat struct {
        <span class="comment">// To make zero values for Rat work w/o initialization,</span>
        <span class="comment">// a zero value of b (len(b) == 0) acts like b == 1.</span>
        <span class="comment">// a.neg determines the sign of the Rat, b.neg is ignored.</span>
        a, b <a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>
}</pre>
			<p>
A Rat represents a quotient a/b of arbitrary precision.
The zero value for a Rat represents the value 0.
</p>


			

			

			
			
			

			
				
				<h3 id="NewRat">func <a href="https://golang.org/src/math/big/rat.go?s=636:664#L14">NewRat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#NewRat">¶</a>
				</h3>
				<pre>func NewRat(a, b <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
NewRat creates a new Rat with numerator a and denominator b.
</p>

				
				
			

			
				
				<h3 id="Rat.Abs">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=8895:8925#L335">Abs</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Abs">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Abs(x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Abs sets z to |x| (the absolute value of x) and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.Add">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=11793:11826#L464">Add</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Add">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Add(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Add sets z to the sum x+y and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.Cmp">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=11649:11678#L459">Cmp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Cmp">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Cmp(y *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Cmp compares x and y and returns:
</p>
<pre>-1 if x &lt;  y
 0 if x == y
+1 if x &gt;  y
</pre>

				
				
				
			
				
				<h3 id="Rat.Denom">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=10166:10192#L392">Denom</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Denom">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Denom() *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Denom returns the denominator of x; it is always &gt; 0.
The result is a reference to x's denominator; it
may change if a new value is assigned to x, and vice versa.
</p>

				
				
				
			
				
				<h3 id="Rat.Float32">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=7124:7171#L254">Float32</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Float32">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Float32() (f <a href="https://golang.org/pkg/builtin/#float32">float32</a>, exact <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Float32 returns the nearest float32 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float32, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.
</p>

				
				
				
			
				
				<h3 id="Rat.Float64">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=7609:7656#L270">Float64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Float64">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Float64() (f <a href="https://golang.org/pkg/builtin/#float64">float64</a>, exact <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
				<p>
Float64 returns the nearest float64 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float64, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.
</p>

				
				
				
			
				
				<h3 id="Rat.FloatString">func (*Rat) <a href="https://golang.org/src/math/big/ratconv.go?s=4897:4939#L210">FloatString</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.FloatString">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) FloatString(prec <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
FloatString returns a string representation of x in decimal form with prec
digits of precision after the decimal point. The last digit is rounded to
nearest, with halves rounded away from zero.
</p>

				
				
				
			
				
				<h3 id="Rat.GobDecode">func (*Rat) <a href="https://golang.org/src/math/big/ratmarsh.go?s=1058:1099#L32">GobDecode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.GobDecode">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) GobDecode(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
GobDecode implements the gob.GobDecoder interface.
</p>

				
				
				
			
				
				<h3 id="Rat.GobEncode">func (*Rat) <a href="https://golang.org/src/math/big/ratmarsh.go?s=432:473#L9">GobEncode</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.GobEncode">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) GobEncode() ([]<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
GobEncode implements the gob.GobEncoder interface.
</p>

				
				
				
			
				
				<h3 id="Rat.Inv">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=9152:9182#L349">Inv</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Inv">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Inv(x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Inv sets z to 1/x and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.IsInt">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=9642:9668#L377">IsInt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.IsInt">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) IsInt() <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
IsInt reports whether the denominator of x is 1.
</p>

				
				
				
			
				
				<h3 id="Rat.MarshalText">func (*Rat) <a href="https://golang.org/src/math/big/ratmarsh.go?s=1555:1607#L51">MarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.MarshalText">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) MarshalText() (text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
MarshalText implements the encoding.TextMarshaler interface.
</p>

				
				
				
			
				
				<h3 id="Rat.Mul">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=12264:12297#L482">Mul</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Mul">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Mul(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Mul sets z to the product x*y and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.Neg">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=9003:9033#L342">Neg</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Neg">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Neg(x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Neg sets z to -x and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.Num">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=9951:9975#L385">Num</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Num">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Num() *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a></pre>
				<p>
Num returns the numerator of x; it may be &lt;= 0.
The result is a reference to x's numerator; it
may change if a new value is assigned to x, and vice versa.
The sign of the numerator corresponds to the sign of x.
</p>

				
				
				
			
				
				<h3 id="Rat.Quo">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=12493:12526#L490">Quo</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Quo">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Quo(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Quo sets z to the quotient x/y and returns z.
If y == 0, a division-by-zero run-time panic occurs.
</p>

				
				
				
			
				
				<h3 id="Rat.RatString">func (*Rat) <a href="https://golang.org/src/math/big/ratconv.go?s=4596:4628#L200">RatString</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.RatString">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) RatString() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
RatString returns a string representation of x in the form "a/b" if b != 1,
and in the form "a" if b == 1.
</p>

				
				
				
			
				
				<h3 id="Rat.Scan">func (*Rat) <a href="https://golang.org/src/math/big/ratconv.go?s=514:564#L13">Scan</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Scan">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Scan(s <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#ScanState">ScanState</a>, ch <a href="https://golang.org/pkg/builtin/#rune">rune</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
Scan is a support routine for fmt.Scanner. It accepts the formats
'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.
</p>

				
				<div id="example_Rat_Scan" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"log"
	"math/big"
)

func main() {
	// The Scan function is rarely used directly;
	// the fmt package recognizes it as an implementation of fmt.Scanner.
	r := new(big.Rat)
	_, err := fmt.Sscan("1.5000", r)
	if err != nil {
		log.Println("error scanning value:", err)
	} else {
		fmt.Println(r)
	}
}
</textarea></div>
				<div class="output"><pre>3/2
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Rat.Set">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=8739:8769#L326">Set</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Set">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Set(x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Set sets z to x (by making a copy of x) and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.SetFloat64">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=797:837#L20">SetFloat64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetFloat64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetFloat64(f <a href="https://golang.org/pkg/builtin/#float64">float64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
SetFloat64 sets z to exactly f and returns z.
If f is not finite, SetFloat returns nil.
</p>

				
				
				
			
				
				<h3 id="Rat.SetFrac">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=7856:7893#L283">SetFrac</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetFrac">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetFrac(a, b *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
SetFrac sets z to a/b and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.SetFrac64">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=8196:8236#L298">SetFrac64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetFrac64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetFrac64(a, b <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
SetFrac64 sets z to a/b and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.SetInt">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=8466:8499#L312">SetInt</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetInt">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetInt(x *<a href="https://golang.org/pkg/math/big/?m=all#Int">Int</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
SetInt sets z to x (by making a copy of x) and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.SetInt64">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=8589:8625#L319">SetInt64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetInt64">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetInt64(x <a href="https://golang.org/pkg/builtin/#int64">int64</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
SetInt64 sets z to x and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.SetString">func (*Rat) <a href="https://golang.org/src/math/big/ratconv.go?s=1118:1164#L31">SetString</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.SetString">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) SetString(s <a href="https://golang.org/pkg/builtin/#string">string</a>) (*<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>, <a href="https://golang.org/pkg/builtin/#bool">bool</a>)</pre>
				<p>
SetString sets z to the value of s and returns z and a boolean indicating
success. s can be given as a fraction "a/b" or as a floating-point number
optionally followed by an exponent. If the operation failed, the value of
z is undefined but the returned value is nil.
</p>

				
				<div id="example_Rat_SetString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

func main() {
	r := new(big.Rat)
	r.SetString("355/113")
	fmt.Println(r.FloatString(3))
}
</textarea></div>
				<div class="output"><pre>3.142
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

				
			
				
				<h3 id="Rat.Sign">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=9541:9565#L372">Sign</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Sign">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Sign() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Sign returns:
</p>
<pre>-1 if x &lt;  0
 0 if x == 0
+1 if x &gt;  0
</pre>

				
				
				
			
				
				<h3 id="Rat.String">func (*Rat) <a href="https://golang.org/src/math/big/ratconv.go?s=4271:4300#L186">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.String">¶</a>
				</h3>
				<pre>func (x *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				<p>
String returns a string representation of x in the form "a/b" (even if b == 1).
</p>

				
				
				
			
				
				<h3 id="Rat.Sub">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=12030:12063#L473">Sub</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.Sub">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) Sub(x, y *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				<p>
Sub sets z to the difference x-y and returns z.
</p>

				
				
				
			
				
				<h3 id="Rat.UnmarshalText">func (*Rat) <a href="https://golang.org/src/math/big/ratmarsh.go?s=1771:1817#L57">UnmarshalText</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.UnmarshalText">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) UnmarshalText(text []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				<p>
UnmarshalText implements the encoding.TextUnmarshaler interface.
</p>

				
				
				
			
				
				<h3 id="Rat.norm">func (*Rat) <a href="https://golang.org/src/math/big/rat.go?s=10343:10368#L400">norm</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Rat.norm">¶</a>
				</h3>
				<pre>func (z *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a>) norm() *<a href="https://golang.org/pkg/math/big/?m=all#Rat">Rat</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="RoundingMode">type <a href="https://golang.org/src/math/big/float.go?s=4819:4841#L115">RoundingMode</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#RoundingMode">¶</a>
			</h2>
			<pre>type RoundingMode <a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
			<p>
RoundingMode determines how a Float value is rounded to the
desired precision. Rounding may change the Float value; the
rounding error is described by the Float's Accuracy.
</p>


			
				<pre>const (
        <span id="ToNearestEven">ToNearestEven</span> <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a> = <a href="https://golang.org/pkg/builtin/#iota">iota</a> <span class="comment">// == IEEE 754-2008 roundTiesToEven</span>
        <span id="ToNearestAway">ToNearestAway</span>                     <span class="comment">// == IEEE 754-2008 roundTiesToAway</span>
        <span id="ToZero">ToZero</span>                            <span class="comment">// == IEEE 754-2008 roundTowardZero</span>
        <span id="AwayFromZero">AwayFromZero</span>                      <span class="comment">// no IEEE 754-2008 equivalent</span>
        <span id="ToNegativeInf">ToNegativeInf</span>                     <span class="comment">// == IEEE 754-2008 roundTowardNegative</span>
        <span id="ToPositiveInf">ToPositiveInf</span>                     <span class="comment">// == IEEE 754-2008 roundTowardPositive</span>
)</pre>
				<p>
These constants define supported rounding modes.
</p>

			

			

			<div id="example_RoundingMode" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<div class="play">
				<div class="input"><textarea class="code" spellcheck="false">package main

import (
	"fmt"
	"math/big"
)

func main() {
	operands := []float64{2.6, 2.5, 2.1, -2.1, -2.5, -2.6}

	fmt.Print("   x")
	for mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {
		fmt.Printf("  %s", mode)
	}
	fmt.Println()

	for _, f64 := range operands {
		fmt.Printf("%4g", f64)
		for mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {
			// sample operands above require 2 bits to represent mantissa
			// set binary precision to 2 to round them to integer values
			f := new(big.Float).SetPrec(2).SetMode(mode).SetFloat64(f64)
			fmt.Printf("  %*g", len(mode.String()), f)
		}
		fmt.Println()
	}

}
</textarea></div>
				<div class="output"><pre>   x  ToNearestEven  ToNearestAway  ToZero  AwayFromZero  ToNegativeInf  ToPositiveInf
 2.6              3              3       2             3              2              3
 2.5              2              3       2             3              2              3
 2.1              2              2       2             3              2              3
-2.1             -2             -2      -2            -3             -3             -2
-2.5             -2             -3      -2            -3             -3             -2
-2.6             -3             -3      -2            -3             -3             -2
</pre></div>
				<div class="buttons">
					<a class="run" title="Run this code [shift-enter]">Run</a>
					<a class="fmt" title="Format this code">Format</a>
					
					<a class="share" title="Share this code">Share</a>
					
				</div>
			</div>
		
	</div>
</div>

			
			

			

			
				
				<h3 id="RoundingMode.String">func (RoundingMode) <a href="https://golang.org/src/math/big/roundingmode_string.go?s=251:288#L1">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#RoundingMode.String">¶</a>
				</h3>
				<pre>func (i <a href="https://golang.org/pkg/math/big/?m=all#RoundingMode">RoundingMode</a>) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Word">type <a href="https://golang.org/src/math/big/arith.go?s=438:455#L2">Word</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#Word">¶</a>
			</h2>
			<pre>type Word <a href="https://golang.org/pkg/builtin/#uintptr">uintptr</a></pre>
			<p>
A Word represents a single digit of a multi-precision unsigned integer.
</p>


			

			

			
			
			

			
				
				<h3 id="addMulVVW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=595:639#L9">addMulVVW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addMulVVW">¶</a>
				</h3>
				<pre>func addMulVVW(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="addMulVVW_g">func <a href="https://golang.org/src/math/big/arith.go?s=5259:5305#L280">addMulVVW_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addMulVVW_g">¶</a>
				</h3>
				<pre>func addMulVVW_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
TODO(gri) Remove use of addWW_g here and then we can remove addWW_g and subWW_g.
</p>

				
				
			
				
				<h3 id="addVV">func <a href="https://golang.org/src/math/big/arith_decl.go?s=311:346#L2">addVV</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addVV">¶</a>
				</h3>
				<pre>func addVV(z, x, y []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="addVV_g">func <a href="https://golang.org/src/math/big/arith.go?s=3343:3380#L167">addVV_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addVV_g">¶</a>
				</h3>
				<pre>func addVV_g(z, x, y []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
The resulting carry c is either 0 or 1.
</p>

				
				
			
				
				<h3 id="addVW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=383:423#L4">addVW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addVW">¶</a>
				</h3>
				<pre>func addVW(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="addVW_g">func <a href="https://golang.org/src/math/big/arith.go?s=4084:4126#L205">addVW_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#addVW_g">¶</a>
				</h3>
				<pre>func addVW_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
The resulting carry c is either 0 or 1.
</p>

				
				
			
				
				<h3 id="divWVW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=640:697#L10">divWVW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divWVW">¶</a>
				</h3>
				<pre>func divWVW(z []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, xn <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="divWVW_g">func <a href="https://golang.org/src/math/big/arith.go?s=5421:5480#L289">divWVW_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divWVW_g">¶</a>
				</h3>
				<pre>func divWVW_g(z []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, xn <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="maxPow">func <a href="https://golang.org/src/math/big/natconv.go?s=831:866#L19">maxPow</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#maxPow">¶</a>
				</h3>
				<pre>func maxPow(b <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (p <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
maxPow returns (b**n, n) such that b**n is the largest power b**n &lt;= _M.
For instance maxPow(10) == (1e19, 19) for 19 decimal digits in a 64bit Word.
In other words, at most n digits in base b fit into a Word.
TODO(gri) replace this with a table, generated at build time.
</p>

				
				
			
				
				<h3 id="mulAddVWW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=547:594#L8">mulAddVWW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulAddVWW">¶</a>
				</h3>
				<pre>func mulAddVWW(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="mulAddVWW_g">func <a href="https://golang.org/src/math/big/arith.go?s=5046:5095#L271">mulAddVWW_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulAddVWW_g">¶</a>
				</h3>
				<pre>func mulAddVWW_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="pow">func <a href="https://golang.org/src/math/big/natconv.go?s=1063:1095#L31">pow</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#pow">¶</a>
				</h3>
				<pre>func pow(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, n <a href="https://golang.org/pkg/builtin/#int">int</a>) (p <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
pow returns x**n for n &gt; 0, and 1 otherwise.
</p>

				
				
			
				
				<h3 id="shlVU">func <a href="https://golang.org/src/math/big/arith_decl.go?s=465:505#L6">shlVU</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shlVU">¶</a>
				</h3>
				<pre>func shlVU(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="shlVU_g">func <a href="https://golang.org/src/math/big/arith.go?s=4586:4628#L241">shlVU_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shlVU_g">¶</a>
				</h3>
				<pre>func shlVU_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="shrVU">func <a href="https://golang.org/src/math/big/arith_decl.go?s=506:546#L7">shrVU</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shrVU">¶</a>
				</h3>
				<pre>func shrVU(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="shrVU_g">func <a href="https://golang.org/src/math/big/arith.go?s=4817:4859#L256">shrVU_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#shrVU_g">¶</a>
				</h3>
				<pre>func shrVU_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="subVV">func <a href="https://golang.org/src/math/big/arith_decl.go?s=347:382#L3">subVV</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#subVV">¶</a>
				</h3>
				<pre>func subVV(z, x, y []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="subVV_g">func <a href="https://golang.org/src/math/big/arith.go?s=3713:3750#L186">subVV_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#subVV_g">¶</a>
				</h3>
				<pre>func subVV_g(z, x, y []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
The resulting carry c is either 0 or 1.
</p>

				
				
			
				
				<h3 id="subVW">func <a href="https://golang.org/src/math/big/arith_decl.go?s=424:464#L5">subVW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#subVW">¶</a>
				</h3>
				<pre>func subVW(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			
				
				<h3 id="subVW_g">func <a href="https://golang.org/src/math/big/arith.go?s=4334:4376#L223">subVW_g</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#subVW_g">¶</a>
				</h3>
				<pre>func subVW_g(z, x []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (c <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				
				
				
			

			
		
			
			
			<h2 id="byteReader">type <a href="https://golang.org/src/math/big/intconv.go?s=5772:5813#L200">byteReader</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#byteReader">¶</a>
			</h2>
			<pre>type byteReader struct {
        <a href="https://golang.org/pkg/fmt/">fmt</a>.<a href="https://golang.org/pkg/fmt/#ScanState">ScanState</a>
}</pre>
			<p>
byteReader is a local wrapper around fmt.ScanState;
it implements the ByteReader interface.
</p>


			

			

			
			
			

			

			
				
				<h3 id="byteReader.ReadByte">func (byteReader) <a href="https://golang.org/src/math/big/intconv.go?s=5815:5859#L204">ReadByte</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#byteReader.ReadByte">¶</a>
				</h3>
				<pre>func (r byteReader) ReadByte() (<a href="https://golang.org/pkg/builtin/#byte">byte</a>, <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
				
				<h3 id="byteReader.UnreadByte">func (byteReader) <a href="https://golang.org/src/math/big/intconv.go?s=5994:6032#L212">UnreadByte</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#byteReader.UnreadByte">¶</a>
				</h3>
				<pre>func (r byteReader) UnreadByte() <a href="https://golang.org/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="decimal">type <a href="https://golang.org/src/math/big/decimal.go?s=1239:1337#L17">decimal</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal">¶</a>
			</h2>
			<pre>type decimal struct {
        mant []<a href="https://golang.org/pkg/builtin/#byte">byte</a> <span class="comment">// mantissa ASCII digits, big-endian</span>
        exp  <a href="https://golang.org/pkg/builtin/#int">int</a>    <span class="comment">// exponent</span>
}</pre>
			<p>
A decimal represents an unsigned floating-point number in decimal representation.
The value of a non-zero decimal d is d.mant * 10**d.exp with 0.5 &lt;= d.mant &lt; 1,
with the most-significant mantissa digit at index 0. For the zero decimal, the
mantissa length and exponent are 0.
The zero value for decimal represents a ready-to-use 0.0.
</p>


			

			

			
			
			

			

			
				
				<h3 id="decimal.String">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=4415:4448#L149">String</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.String">¶</a>
				</h3>
				<pre>func (x *decimal) String() <a href="https://golang.org/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="decimal.at">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=1425:1457#L23">at</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.at">¶</a>
				</h3>
				<pre>func (d *decimal) at(i <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
at returns the i'th mantissa digit, starting with the most significant digit at 0.
</p>

				
				
				
			
				
				<h3 id="decimal.init">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=2316:2356#L45">init</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.init">¶</a>
				</h3>
				<pre>func (x *decimal) init(m nat, shift <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
Init initializes x to the decimal representation of m &lt;&lt; shift (for
shift &gt;= 0), or m &gt;&gt; -shift (for shift &lt; 0).
</p>

				
				
				
			
				
				<h3 id="decimal.round">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=5653:5683#L200">round</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.round">¶</a>
				</h3>
				<pre>func (x *decimal) round(n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
round sets x to (at most) n mantissa digits by rounding it
to the nearest even value with n (or fever) mantissa digits.
If n &lt; 0, x remains unchanged.
</p>

				
				
				
			
				
				<h3 id="decimal.roundDown">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=6276:6310#L237">roundDown</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.roundDown">¶</a>
				</h3>
				<pre>func (x *decimal) roundDown(n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				
				
				
				
			
				
				<h3 id="decimal.roundUp">func (*decimal) <a href="https://golang.org/src/math/big/decimal.go?s=5822:5854#L212">roundUp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#decimal.roundUp">¶</a>
				</h3>
				<pre>func (x *decimal) roundUp(n <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="divisor">type <a href="https://golang.org/src/math/big/natconv.go?s=11709:11906#L413">divisor</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#divisor">¶</a>
			</h2>
			<pre>type divisor struct {
        bbb     nat <span class="comment">// divisor</span>
        nbits   <a href="https://golang.org/pkg/builtin/#int">int</a> <span class="comment">// bit length of divisor (discounting leading zeros) ~= log2(bbb)</span>
        ndigits <a href="https://golang.org/pkg/builtin/#int">int</a> <span class="comment">// digit length of divisor in terms of output base digits</span>
}</pre>
			

			

			

			
			
			

			

			
		
			
			
			<h2 id="form">type <a href="https://golang.org/src/math/big/float.go?s=4526:4540#L103">form</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#form">¶</a>
			</h2>
			<pre>type form <a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
			<p>
A form value describes the internal representation.
</p>


			
				<pre>const (
        <span id="zero">zero</span> form = <a href="https://golang.org/pkg/builtin/#iota">iota</a>
        <span id="finite">finite</span>
        <span id="inf">inf</span>
)</pre>
				<p>
The form value order is relevant - do not change!
</p>

			

			

			
			
			

			

			
		
			
			
			<h2 id="nat">type <a href="https://golang.org/src/math/big/nat.go?s=909:924#L18">nat</a>
				<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat">¶</a>
			</h2>
			<pre>type nat []<a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a></pre>
			<p>
An unsigned integer x of the form
</p>
<pre>x = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]
</pre>
<p>
with 0 &lt;= x[i] &lt; _B and 0 &lt;= i &lt; n is stored in a slice of length n,
with the digits x[i] as the slice elements.
</p>
<p>
A number is normalized if the slice contains no leading 0 digits.
During arithmetic operations, denormalized values may occur but are
always normalized before returning the final result. The normalized
representation of 0 is the empty or nil slice (length = 0).
</p>


			

			

			
			
			

			
				
				<h3 id="getNat">func <a href="https://golang.org/src/math/big/nat.go?s=12284:12306#L536">getNat</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#getNat">¶</a>
				</h3>
				<pre>func getNat(n <a href="https://golang.org/pkg/builtin/#int">int</a>) nat</pre>
				<p>
getNat returns a nat of len n. The contents may not be zero.
</p>

				
				
			
				
				<h3 id="mulDenom">func <a href="https://golang.org/src/math/big/rat.go?s=11164:11194#L431">mulDenom</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#mulDenom">¶</a>
				</h3>
				<pre>func mulDenom(z, x, y nat) nat</pre>
				<p>
mulDenom sets z to the denominator product x*y (by taking into
account that 0 values for x or y must be interpreted as 1) and
returns z.
</p>

				
				
			

			
				
				<h3 id="nat.add">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1926:1956#L87">add</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.add">¶</a>
				</h3>
				<pre>func (z nat) add(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.and">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=17473:17503#L785">and</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.and">¶</a>
				</h3>
				<pre>func (z nat) and(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.andNot">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=17653:17686#L801">andNot</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.andNot">¶</a>
				</h3>
				<pre>func (z nat) andNot(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.bit">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=16974:17003#L754">bit</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.bit">¶</a>
				</h3>
				<pre>func (x nat) bit(i <a href="https://golang.org/pkg/builtin/#uint">uint</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
bit returns the value of the i'th bit, with lsb == bit 0.
</p>

				
				
				
			
				
				<h3 id="nat.bitLen">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=14309:14334#L634">bitLen</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.bitLen">¶</a>
				</h3>
				<pre>func (x nat) bitLen() <a href="https://golang.org/pkg/builtin/#int">int</a></pre>
				<p>
Length of x in bits. x must be normalized.
</p>

				
				
				
			
				
				<h3 id="nat.bytes">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=27555:27593#L1256">bytes</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.bytes">¶</a>
				</h3>
				<pre>func (z nat) bytes(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) (i <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				<p>
bytes writes the value of z into buf using big-endian encoding.
len(buf) must be &gt;= len(z)*_S. The value of z is encoded in the
slice buf[i:]. The number i of unused bytes at the beginning of
buf is returned as result.
</p>

				
				
				
			
				
				<h3 id="nat.clear">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=987:1007#L26">clear</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.clear">¶</a>
				</h3>
				<pre>func (z nat) clear()</pre>
				
				
				
				
			
				
				<h3 id="nat.cmp">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=2662:2693#L141">cmp</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.cmp">¶</a>
				</h3>
				<pre>func (x nat) cmp(y nat) (r <a href="https://golang.org/pkg/builtin/#int">int</a>)</pre>
				
				
				
				
			
				
				<h3 id="nat.convertWords">func (nat) <a href="https://golang.org/src/math/big/natconv.go?s=9378:9460#L340">convertWords</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.convertWords">¶</a>
				</h3>
				<pre>func (q nat) convertWords(s []<a href="https://golang.org/pkg/builtin/#byte">byte</a>, b <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, ndigits <a href="https://golang.org/pkg/builtin/#int">int</a>, bb <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, table []divisor)</pre>
				<p>
Convert words of q to base b digits in s. If q is large, it is recursively "split in half"
by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using
repeated nat/Word division.
</p>
<p>
The iterative method processes n Words by n divW() calls, each of which visits every Word in the
incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s.
Recursive conversion divides q by its approximate square root, yielding two parts, each half
the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s
plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and
is made better by splitting the subblocks recursively. Best is to split blocks until one more
split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the
iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the
range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and
~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for
specific hardware.
</p>

				
				
				
			
				
				<h3 id="nat.div">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=11934:11975#L513">div</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.div">¶</a>
				</h3>
				<pre>func (z nat) div(z2, u, v nat) (q, r nat)</pre>
				
				
				
				
			
				
				<h3 id="nat.divLarge">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=12667:12714#L556">divLarge</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.divLarge">¶</a>
				</h3>
				<pre>func (z nat) divLarge(u, uIn, v nat) (q, r nat)</pre>
				<p>
q = (uIn-r)/v, with 0 &lt;= r &lt; y
Uses z as storage for q, and u as storage for r if possible.
See Knuth, Volume 2, section 4.3.1, Algorithm D.
Preconditions:
</p>
<pre>len(v) &gt;= 2
len(uIn) &gt;= len(v)
</pre>

				
				
				
			
				
				<h3 id="nat.divW">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=11638:11686#L494">divW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.divW">¶</a>
				</h3>
				<pre>func (z nat) divW(x nat, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (q nat, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
q = (x-r)/y, with 0 &lt;= r &lt; y
</p>

				
				
				
			
				
				<h3 id="nat.expNN">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=19481:19516#L907">expNN</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.expNN">¶</a>
				</h3>
				<pre>func (z nat) expNN(x, y, m nat) nat</pre>
				<p>
If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m;
otherwise it sets z to x**y. The result is the value of z.
</p>

				
				
				
			
				
				<h3 id="nat.expNNMontgomery">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=22909:22954#L1071">expNNMontgomery</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.expNNMontgomery">¶</a>
				</h3>
				<pre>func (z nat) expNNMontgomery(x, y, m nat) nat</pre>
				<p>
expNNMontgomery calculates x**y mod m using a fixed, 4-bit window.
Uses Montgomery representation.
</p>

				
				
				
			
				
				<h3 id="nat.expNNWindowed">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=21552:21595#L1007">expNNWindowed</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.expNNWindowed">¶</a>
				</h3>
				<pre>func (z nat) expNNWindowed(x, y, m nat) nat</pre>
				<p>
expNNWindowed calculates x**y mod m using a fixed, 4-bit window.
</p>

				
				
				
			
				
				<h3 id="nat.expWW">func (nat) <a href="https://golang.org/src/math/big/natconv.go?s=12021:12054#L425">expWW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.expWW">¶</a>
				</h3>
				<pre>func (z nat) expWW(x, y <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) nat</pre>
				<p>
expWW computes x**y
</p>

				
				
				
			
				
				<h3 id="nat.itoa">func (nat) <a href="https://golang.org/src/math/big/natconv.go?s=6174:6218#L234">itoa</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.itoa">¶</a>
				</h3>
				<pre>func (x nat) itoa(neg <a href="https://golang.org/pkg/builtin/#bool">bool</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
itoa is like utoa but it prepends a '-' if neg &amp;&amp; x != 0.
</p>

				
				
				
			
				
				<h3 id="nat.make">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1141:1169#L40">make</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.make">¶</a>
				</h3>
				<pre>func (z nat) make(n <a href="https://golang.org/pkg/builtin/#int">int</a>) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.modW">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=18477:18511#L862">modW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.modW">¶</a>
				</h3>
				<pre>func (x nat) modW(d <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) (r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>)</pre>
				<p>
modW returns x % d.
</p>

				
				
				
			
				
				<h3 id="nat.montgomery">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=3978:4033#L201">montgomery</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.montgomery">¶</a>
				</h3>
				<pre>func (z nat) montgomery(x, y, m nat, k <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>, n <a href="https://golang.org/pkg/builtin/#int">int</a>) nat</pre>
				<p>
montgomery computes z mod m = x*y*2**(-n*_W) mod m,
assuming k = -1/m mod 2**_W.
z is used for storing the result which is returned;
z must not alias x, y or m.
See Gueron, "Efficient Software Implementations of Modular Exponentiation".
<a href="https://eprint.iacr.org/2011/239.pdf">https://eprint.iacr.org/2011/239.pdf</a>
In the terminology of that paper, this is an "Almost Montgomery Multiplication":
x and y are required to satisfy 0 &lt;= z &lt; 2**(n*_W) and then the result
z is guaranteed to satisfy 0 &lt;= z &lt; 2**(n*_W), but it may not be &lt; m.
</p>

				
				
				
			
				
				<h3 id="nat.mul">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=9019:9049#L391">mul</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.mul">¶</a>
				</h3>
				<pre>func (z nat) mul(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.mulAddWW">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=2950:2993#L168">mulAddWW</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.mulAddWW">¶</a>
				</h3>
				<pre>func (z nat) mulAddWW(x nat, y, r <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.mulRange">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=11233:11271#L477">mulRange</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.mulRange">¶</a>
				</h3>
				<pre>func (z nat) mulRange(a, b <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) nat</pre>
				<p>
mulRange computes the product of all the unsigned integers in the
range [a, b] inclusively. If a &gt; b (empty range), the result is 1.
</p>

				
				
				
			
				
				<h3 id="nat.norm">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1047:1070#L32">norm</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.norm">¶</a>
				</h3>
				<pre>func (z nat) norm() nat</pre>
				
				
				
				
			
				
				<h3 id="nat.or">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=17859:17888#L818">or</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.or">¶</a>
				</h3>
				<pre>func (z nat) or(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.probablyPrime">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=25654:25695#L1168">probablyPrime</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.probablyPrime">¶</a>
				</h3>
				<pre>func (n nat) probablyPrime(reps <a href="https://golang.org/pkg/builtin/#int">int</a>) <a href="https://golang.org/pkg/builtin/#bool">bool</a></pre>
				<p>
probablyPrime performs n Miller-Rabin tests to check whether x is prime.
If x is prime, it returns true.
If x is not prime, it returns false with probability at least 1 - ¼ⁿ.
</p>
<p>
It is not suitable for judging primes that an adversary may have crafted
to fool this test.
</p>

				
				
				
			
				
				<h3 id="nat.random">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=18752:18810#L871">random</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.random">¶</a>
				</h3>
				<pre>func (z nat) random(rand *<a href="https://golang.org/pkg/math/rand/">rand</a>.<a href="https://golang.org/pkg/math/rand/#Rand">Rand</a>, limit nat, n <a href="https://golang.org/pkg/builtin/#int">int</a>) nat</pre>
				<p>
random creates a random integer in [0..limit), using the space in z if
possible. n is the bit length of limit.
</p>

				
				
				
			
				
				<h3 id="nat.scan">func (nat) <a href="https://golang.org/src/math/big/natconv.go?s=2971:3064#L77">scan</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.scan">¶</a>
				</h3>
				<pre>func (z nat) scan(r <a href="https://golang.org/pkg/io/">io</a>.<a href="https://golang.org/pkg/io/#ByteScanner">ByteScanner</a>, base <a href="https://golang.org/pkg/builtin/#int">int</a>, fracOk <a href="https://golang.org/pkg/builtin/#bool">bool</a>) (res nat, b, count <a href="https://golang.org/pkg/builtin/#int">int</a>, err <a href="https://golang.org/pkg/builtin/#error">error</a>)</pre>
				<p>
scan scans the number corresponding to the longest possible prefix
from r representing an unsigned number in a given conversion base.
It returns the corresponding natural number res, the actual base b,
a digit count, and a read or syntax error err, if any.
</p>
<pre>	number   = [ prefix ] mantissa .
	prefix   = "0" [ "x" | "X" | "b" | "B" ] .
     mantissa = digits | digits "." [ digits ] | "." digits .
	digits   = digit { digit } .
	digit    = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
</pre>
<p>
Unless fracOk is set, the base argument must be 0 or a value between
2 and MaxBase. If fracOk is set, the base argument must be one of
0, 2, 10, or 16. Providing an invalid base argument leads to a run-
time panic.
</p>
<p>
For base 0, the number prefix determines the actual base: A prefix of
“0x” or “0X” selects base 16; if fracOk is not set, the “0” prefix
selects base 8, and a “0b” or “0B” prefix selects base 2. Otherwise
the selected base is 10 and no prefix is accepted.
</p>
<p>
If fracOk is set, an octal prefix is ignored (a leading “0” simply
stands for a zero digit), and a period followed by a fractional part
is permitted. The result value is computed as if there were no period
present; and the count value is used to determine the fractional part.
</p>
<p>
A result digit count &gt; 0 corresponds to the number of (non-prefix) digits
parsed. A digit count &lt;= 0 indicates the presence of a period (if fracOk
is set, only), and -count is the number of fractional digits found.
In this case, the actual value of the scanned number is res * b**count.
</p>

				
				
				
			
				
				<h3 id="nat.set">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1851:1878#L81">set</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.set">¶</a>
				</h3>
				<pre>func (z nat) set(x nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.setBit">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=16481:16527#L724">setBit</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.setBit">¶</a>
				</h3>
				<pre>func (z nat) setBit(x nat, i <a href="https://golang.org/pkg/builtin/#uint">uint</a>, b <a href="https://golang.org/pkg/builtin/#uint">uint</a>) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.setBytes">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=27877:27914#L1275">setBytes</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.setBytes">¶</a>
				</h3>
				<pre>func (z nat) setBytes(buf []<a href="https://golang.org/pkg/builtin/#byte">byte</a>) nat</pre>
				<p>
setBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.
</p>

				
				
				
			
				
				<h3 id="nat.setUint64">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1514:1550#L59">setUint64</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.setUint64">¶</a>
				</h3>
				<pre>func (z nat) setUint64(x <a href="https://golang.org/pkg/builtin/#uint64">uint64</a>) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.setWord">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=1410:1442#L50">setWord</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.setWord">¶</a>
				</h3>
				<pre>func (z nat) setWord(x <a href="https://golang.org/pkg/math/big/?m=all#Word">Word</a>) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.shl">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=16087:16122#L694">shl</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.shl">¶</a>
				</h3>
				<pre>func (z nat) shl(x nat, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) nat</pre>
				<p>
z = x &lt;&lt; s
</p>

				
				
				
			
				
				<h3 id="nat.shr">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=16307:16342#L710">shr</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.shr">¶</a>
				</h3>
				<pre>func (z nat) shr(x nat, s <a href="https://golang.org/pkg/builtin/#uint">uint</a>) nat</pre>
				<p>
z = x &gt;&gt; s
</p>

				
				
				
			
				
				<h3 id="nat.sticky">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=17218:17250#L765">sticky</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.sticky">¶</a>
				</h3>
				<pre>func (x nat) sticky(i <a href="https://golang.org/pkg/builtin/#uint">uint</a>) <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
sticky returns 1 if there's a 1 bit within the
i least significant bits, otherwise it returns 0.
</p>

				
				
				
			
				
				<h3 id="nat.sub">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=2283:2313#L113">sub</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.sub">¶</a>
				</h3>
				<pre>func (z nat) sub(x, y nat) nat</pre>
				
				
				
				
			
				
				<h3 id="nat.trailingZeroBits">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=15909:15945#L681">trailingZeroBits</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.trailingZeroBits">¶</a>
				</h3>
				<pre>func (x nat) trailingZeroBits() <a href="https://golang.org/pkg/builtin/#uint">uint</a></pre>
				<p>
trailingZeroBits returns the number of consecutive least significant zero
bits of x.
</p>

				
				
				
			
				
				<h3 id="nat.utoa">func (nat) <a href="https://golang.org/src/math/big/natconv.go?s=6045:6079#L229">utoa</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.utoa">¶</a>
				</h3>
				<pre>func (x nat) utoa(base <a href="https://golang.org/pkg/builtin/#int">int</a>) []<a href="https://golang.org/pkg/builtin/#byte">byte</a></pre>
				<p>
utoa converts x to an ASCII representation in the given base;
base must be between 2 and MaxBase, inclusive.
</p>

				
				
				
			
				
				<h3 id="nat.xor">func (nat) <a href="https://golang.org/src/math/big/nat.go?s=18082:18112#L837">xor</a>
					<a class="permalink" href="https://golang.org/pkg/math/big/?m=all#nat.xor">¶</a>
				</h3>
				<pre>func (z nat) xor(x, y nat) nat</pre>
				
				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="https://golang.org/src/math/big/float.go?s=38735:38827#L1398" style="float: left;">☞</a> <p>
When rounding ToNegativeInf, the sign of Float values rounded to 0 is incorrect.
</p>
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.7.3.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="https://golang.org/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->

<!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
<script type="text/javascript" src="./big - The Go Programming Language_files/jquery.min.js"></script>
<script type="text/javascript" src="./big - The Go Programming Language_files/jquery.treeview.js"></script>
<script type="text/javascript" src="./big - The Go Programming Language_files/jquery.treeview.edit.js"></script>


<script type="text/javascript" src="./big - The Go Programming Language_files/playground.js"></script>

<script>var goVersion = "go1.7.3";</script>
<script type="text/javascript" src="./big - The Go Programming Language_files/godocs.js"></script>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>



</body></html>